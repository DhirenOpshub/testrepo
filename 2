package layer2;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Random;

import org.apache.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellUtil;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import layer1.Layer1;
import layer4.ExcelInfo;
import layer4.IntegrationGroupData;

public class Layer2 {

	private static final String INTEGRATION_DETAILS_FILE = "IntegrationDetails2.properties";
	private static final String RECONCILE_DETAILS_FILE = "ReconciliationDetails2.properties";

	private static final String SOURCE_SYSTEM_NAME_KEY = "sourceSystemName";
	private static final String TARGET_SYSTEM_NAME_KEY = "targetSystemName";
	private static final String TOTAL_GROUP_KEY = "totalGroups";
	private static final String START_COUNT_PREFIX = "startCount";
	private static final String END_COUNT_PREFIX = "endCount";
	private static final String CREATE_EVENT_NAME = "Create";
	private static final String UPDATE_EVENT_NAME = "Update";
	private static final String DELETE_EVENT_NAME = "Delete";
	private static final Integer DEFAULT_INTEGRATION_WORKFLOW_ID = 1;
	private static final String SCHEDULE_ID_KEY = "scheduleId";
	private static final String START_COUNT = "startCount";
	private static final String END_COUNT = "endCount";
	private static final String POLLING_TIME = "pollingTime";
	private static final String SOURCE_ISSUE_TYPE_KEY = "sourceIssueTypes";
	private static final String TARGET_ISSUE_TYPE_KEY = "targetIssueTypes";
	private static final String SOURCE_PROJECT_KEY = "sourceProjects";
	private static final String TARGET_PROJECT_KEY = "targetProjects";
	private static final String POLLING_TYPE = "pollingType";
	private static final String PARENT_FOLDER_PATH_KEY = "parentFolderPath";
	private static final String MAPPING_NAME = "mappingName";
	private static final String NAME_POSTFIX = "postFixName";
	public static final String ENABLE_CRITERIA = "enable_criteria";
	public static final String ADDITIONAL_DATA = "additional_data";
	public static final String CHECK_SOURCE_ENTITY_COUNT = "check_source_entity_count";
	public static final String REMOTE_LINK = "remote_link";
	public static final String REMOTE_ID = "remote_id";
	public static final String CRITERIA_QUERY = "criteria_query";
	public static final String CRITERIA_STORAGE = "criteria_storage";
	public static final String CRITERIA_STORAGE_FIELD = "criteria_storage_field";

	private static final int DEFAULT_RECONCILE_WORKFLOW_ID = 24;

	private static final String CURRENT_STATE_FLAG = "1";

	private static final int PROJECT_ID_COL_INDEX = 1;
	private static final int WORKSPACE_ID_COL_INDEX = 0;
	private static final int SOURCE_PROJECT_COL_INDEX = 2;
	private static final int TARGET_PROJECT_COL_INDEX = 3;
	private static final int JIRA_PROJ_KEY_COL_INDEX = 4;
	private static final int INTEGRATION_NAME_COL_INDEX = 5;
	private static final int INTEGRATION_GROUP_ID_COL_INDEX = 6;
	private static final int FOLDER_ID_COL_INDEX = 7;
	private static final int FOLDER_PATH_COL_INDEX = 8;
	private static final int PROD_URL_COL_INDEX = 9;
	private static final int MILESTONE_ID_COL_INDEX = 10;
	private static final int RELEASE_ID_COL_INDEX = 11;
	private static final int ITERATION_ID_COL_INDEX = 12;
	private static final int DEFECT_ID_COL_INDEX = 13;
	private static final int USER_STORY_ID_COL_INDEX = 14;
	private static final int FEATURE_ID_COL_INDEX = 15;
	private static final int INITIATIVE_ID_COL_INDEX = 16;
	private static final int TASK_ID_COL_INDEX = 17;
	private static final int MINIMUM_BUS_INC_COL_INDEX = 18;

	private static final String[] BASIC_INTEGRATION_DETAIL_HEADER = new String[] { "Rally Workspace ID",
			"Rally Project ID", "Rally Project Name", "Jira Project Name", "Jira Project Key", "Integration Name",
			"Group Id", "Folder ID", "Folder Path", "Production URL" };
	
	private static final String[] JIRA_ISSUE_TYPE = new String[] { "Story","Task","Bug","Epic" };

	private static final Logger LOGGER = Logger.getLogger(Layer2.class);

	private static Properties integrationDetails = new Properties();
	private static Properties reconcileDetails;
	private static int[] projectStartCount;
	private static int[] projectEndCount;
	private static int totalGroups;

	private static HashMap<String, String> sourceSystemProjects = null;
	private static HashMap<String, String> targetSystemProjects = null;

	private static HashMap<String, String> excelNameSourceFullNameMap = new HashMap<>();
	private static HashMap<String, String> excelNameTargetFullNameMap = new HashMap<>();

	private static HashMap<Integer, int[]> podToStartCountMap = new HashMap<>();
	private static HashMap<Integer, int[]> podToEndCountMap = new HashMap<>();

	// using it as cache to store projects by system id
	private static HashMap<Integer, HashMap<Integer, HashMap<String, String>>> systemIdProjectMap = new HashMap<>();

	static {
		InputStream inputStream = null;
		try {
			inputStream = Layer2.class.getClassLoader().getResourceAsStream(INTEGRATION_DETAILS_FILE);
			integrationDetails.load(inputStream);
		} catch (Exception e) {
			LOGGER.error("Failed to load properties from " + INTEGRATION_DETAILS_FILE
					+ " file. Please make sure that the file exists or group information is provided properly. Caused by: "
					+ e.getMessage());
		}
	}

	public static void resetProperties(int totalProds, int currentPod) throws Exception {
		try {
			totalGroups = Integer.parseInt(integrationDetails.getProperty(TOTAL_GROUP_KEY));
			projectStartCount = new int[totalGroups];
			projectEndCount = new int[totalGroups];
			for (int i = 0; i < totalGroups; ++i) {
				projectStartCount[i] = Integer.parseInt(integrationDetails.getProperty(START_COUNT_PREFIX + (i + 1)));
				projectEndCount[i] = Integer.parseInt(integrationDetails.getProperty(END_COUNT_PREFIX + (i + 1)));
			}
			podToStartCountMap.put(currentPod, projectStartCount);
			podToEndCountMap.put(currentPod, projectEndCount);
		} catch (Exception e) {
			LOGGER.error("Exception error occurred because of " + e.getMessage());
			throw new Exception("Error occurred while reseting properties.");
		}

	}

	
	static void printDataToExcel(IntegrationGroupData integrationData) throws Exception {
		LOGGER.debug("Writing data to the excel file.");
		Workbook workbook = null;
		File outputFile = null;
		FileOutputStream outputStream = null;
		FileInputStream inputStream = null;
		String outputFileName = getOutputFileName();
		try {
			boolean doesFileExist = false;
			outputFile = new File(outputFileName);
			if (outputFile.exists()) {
				LOGGER.debug("Output file: " + outputFileName + " already exists, hence not creating new one.");
				doesFileExist = true;
				inputStream = new FileInputStream(outputFile);
				if (outputFileName.endsWith(".xlsx")) {
					workbook = new XSSFWorkbook(inputStream);
				} else if (outputFileName.endsWith(".xls")) {
					workbook = new HSSFWorkbook(inputStream);
				} else {
					// do nothing
				}

			} else {
				// create new
				LOGGER.debug("Output file does not exist. Hence creating:" + outputFileName);
				workbook = new XSSFWorkbook();
				Sheet sheet = workbook.createSheet(getOutputFileSheetName());
				Row firstRow = sheet.createRow(0);
				CellRangeAddress cellRangeAddress = new CellRangeAddress(0, 0, 0, 9);
				sheet.addMergedRegion(cellRangeAddress);
				Cell basicIntegrationCell = CellUtil.createCell(firstRow, 0, "Basic Intgeration Details");
				CellUtil.setAlignment(basicIntegrationCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 10, 18);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationDetailCell = CellUtil.createCell(firstRow, 10, "Integration Details");
				CellUtil.setAlignment(integrationDetailCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 19, 27);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationStatusCell = CellUtil.createCell(firstRow, 19, "Integration Status");
				CellUtil.setAlignment(integrationStatusCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 28, 36);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationFailureCell = CellUtil.createCell(firstRow, 28, "Integration Failures");
				CellUtil.setAlignment(integrationFailureCell, HorizontalAlignment.CENTER);

				Row secondRow = sheet.createRow(1);
				int col = 0;
				for (int i = 0; i < BASIC_INTEGRATION_DETAIL_HEADER.length; ++i) {
					Cell currentCell = secondRow.createCell(i);
					currentCell.setCellValue(BASIC_INTEGRATION_DETAIL_HEADER[i]);
					col++;
				}
				for (int t = 1; t <= 3; ++t) {
					for (int i = 0; i < JIRA_ISSUE_TYPE.length; ++i) {
						Cell currentCell = secondRow.createCell(col);
						currentCell.setCellValue(JIRA_ISSUE_TYPE[i]);
						col++;
					}
				}

			}
			Sheet sheet = workbook.getSheet(getOutputFileSheetName());
			if (sheet != null) {
				LOGGER.debug("Writing to the file");
				int lastRow = sheet.getLastRowNum();
				Row row = sheet.createRow(lastRow + 1);
				Cell sourceProjectCell = row.createCell(SOURCE_PROJECT_COL_INDEX);
				sourceProjectCell.setCellValue(integrationData.getSourceProjectName());
				Cell targetProjectCell = row.createCell(TARGET_PROJECT_COL_INDEX);
				targetProjectCell.setCellValue(integrationData.getTargetProjectName());
				Cell integrationNameCell = row.createCell(INTEGRATION_NAME_COL_INDEX);
				integrationNameCell.setCellValue(integrationData.getIntegrationGroupName());
				Cell groupIdCell = row.createCell(INTEGRATION_GROUP_ID_COL_INDEX);
				groupIdCell.setCellValue(integrationData.getIntegrationGroupId());
				Cell folderIdCell = row.createCell(FOLDER_ID_COL_INDEX);
				folderIdCell.setCellValue(integrationData.getFolderId());
				Cell folderPathCell = row.createCell(FOLDER_PATH_COL_INDEX);
				folderPathCell.setCellValue(integrationData.getFolderPath());
				Cell productionUrlCell = row.createCell(PROD_URL_COL_INDEX);
				productionUrlCell.setCellValue(integrationData.getProductionUrl());
				Cell milestoneCell = row.createCell(MILESTONE_ID_COL_INDEX);
				//milestoneCell.setCellValue(integrationData.getMilestoneId());
				Cell releaseCell = row.createCell(RELEASE_ID_COL_INDEX);
			//	releaseCell.setCellValue(integrationData.getReleaseId());
				Cell iterationCell = row.createCell(ITERATION_ID_COL_INDEX);
			//	iterationCell.setCellValue(integrationData.getIterationId());
				Cell defectCell = row.createCell(DEFECT_ID_COL_INDEX);
			//	defectCell.setCellValue(integrationData.getDefectId());
				Cell userStoryCell = row.createCell(USER_STORY_ID_COL_INDEX);
				//userStoryCell.setCellValue(integrationData.getUserStoryId());
				Cell featureCell = row.createCell(FEATURE_ID_COL_INDEX);
		//		featureCell.setCellValue(integrationData.getFeatureId());
				Cell initiativeCell = row.createCell(INITIATIVE_ID_COL_INDEX);
	//			initiativeCell.setCellValue(integrationData.getInitiativeId());
				Cell taskCell = row.createCell(TASK_ID_COL_INDEX);
				taskCell.setCellValue(integrationData.getTaskId());
				Cell minimumBusCell = row.createCell(MINIMUM_BUS_INC_COL_INDEX);
		//		minimumBusCell.setCellValue(integrationData.getMinimumBusinessId());
				Cell workspaceCell = row.createCell(WORKSPACE_ID_COL_INDEX);
	//			workspaceCell.setCellValue(integrationData.getJiraSourceProjectKey());
				Cell projectCell = row.createCell(PROJECT_ID_COL_INDEX);
				projectCell.setCellValue(integrationData.getProjectId());
				Cell projectKeyCell = row.createCell(JIRA_PROJ_KEY_COL_INDEX);
	//			projectKeyCell.setCellValue(integrationData.getJiraProjectKey());
				for (int i = 19; i <= 21; ++i) {
					Cell statusCell = row.createCell(i);
					statusCell.setCellValue("1");
				}
				for (int i = 22; i <= 27; ++i) {
					Cell statusCell = row.createCell(i);
					statusCell.setCellValue("0");
				}
			} else {
				// throw exception
				LOGGER.error("Could not find the sheet name:" + getOutputFileSheetName());
				throw new Exception(
						"Could not find the sheet name: " + getOutputFileName() + " in file:" + getOutputFileName());
			}
			if (doesFileExist) {
				outputStream = new FileOutputStream(outputFile);
			} else {
				outputStream = new FileOutputStream(new File(getOutputFileName()));
			}
			workbook.write(outputStream);
		} catch (Exception e) {
			LOGGER.error("Error occurred while writing to the excel file. Caused by:" + e.getMessage());
			throw new Exception("Error occurred while writing to the output file. " + e.getMessage());
		} finally {
			if (workbook != null)
				workbook.close();
			if (outputStream != null)
				outputStream.close();
			if (inputStream != null)
				inputStream.close();
		}
	}

	static String getOutputFileName() {
		return integrationDetails.getProperty("outputFileName");
	}

	static String getOutputFileSheetName() {
		return integrationDetails.getProperty("outputSheetName");
	}

	static Integer getWorkflowId(int groupNo, int currentIndex) {
		String[] workflowIds = integrationDetails.getProperty("workflowIds" + groupNo).split(",");
		return Integer.parseInt(workflowIds[currentIndex]);
	}

	static List<EAISourceEventInfo> getEvents(final int groupNo, final String mappingId, int currentIndex)
			throws Exception {
		List<EAISourceEventInfo> events = new ArrayList<>();
		for (int i = 1; i <= 3; ++i) {
			EAISourceEventInfo event = new EAISourceEventInfo();
			if(i==3)
				event.setEventId(i+1);
			else
				event.setEventId(i);
			if (i == 1)
				event.setEventName(CREATE_EVENT_NAME);
			else if(i == 2)
				event.setEventName(UPDATE_EVENT_NAME);
			else
				event.setEventName(DELETE_EVENT_NAME);

			List<EAIProcessDefinfo> processDefList = new ArrayList<>();
			EAIProcessDefinfo processDef = new EAIProcessDefinfo();
			processDef.setActive(true);
			// workflow id

			int workflowId = getWorkflowId(groupNo, currentIndex);
			LOGGER.debug("Workflow id:" + workflowId);
			if (workflowId <= 0) {
				throw new Exception("Error occurred while setting workflow id. Workflow id:" + workflowId);
			}

			processDef.setProcessDefnId(workflowId);

			processDef.setEventProcessDefnId(-1);

			// mapping id
			processDef.setTransformations(Integer.parseInt(mappingId));

			processDefList.add(processDef);
			event.setProcessDefs(processDefList);
			events.add(event);
		}
		return events;
	}

	static IntegrationContext getIntegrationContext() {
		IntegrationContext integrationContext = new IntegrationContext();
		integrationContext.setPollingTime(getPollingTime());
		return integrationContext;
	}

	public static HashMap<String, String> getProjectsFromSystemId(int systemId, String url, String username,
			String password, boolean returnInternalToDisplayMap, int currentPod,Boolean isDoorsSystem) throws Exception {
		HashMap<Integer, HashMap<String, String>> currentPodSystemProjects = systemIdProjectMap.get(currentPod);
		if (currentPodSystemProjects != null && !currentPodSystemProjects.isEmpty()) {
			HashMap<String, String> systemProjects = currentPodSystemProjects.get(systemId);
			if (systemProjects != null && !systemProjects.isEmpty()) {
				LOGGER.debug("Projects are already loaded for system id:" + systemId + " with prod instance:"
						+ currentPod + ". Hence not loading again, returning projects...");
				return systemProjects;
			}
		}
		LOGGER.debug("************** Fetching projects for SystemID: " + systemId + "  **************");
		HashMap<String, String> fetchedProjects = Layer1.loadProjectsFromSystemId(url, systemId, username, password,
				returnInternalToDisplayMap,isDoorsSystem);
		HashMap<Integer, HashMap<String, String>> alreadyStoredProjects = systemIdProjectMap.get(currentPod);
		if (alreadyStoredProjects == null) {
			alreadyStoredProjects = new HashMap<>();
		}
		alreadyStoredProjects.put(systemId, fetchedProjects);
		systemIdProjectMap.put(currentPod, alreadyStoredProjects);
		return fetchedProjects;
	}

//	public static HashMap<String, String> getSourceSystemProjects(String url, int sourceSystemId, String username,
//			String password, boolean returnInternalToDisplayMap) throws Exception {
//		LOGGER.debug("Fetching projects from system id: " + sourceSystemId);
//		if (sourceSystemProjects != null) {
//			LOGGER.debug("Projects are already loaded, hence not loading again. Returning projects");
//			return sourceSystemProjects;
//		}
//		sourceSystemProjects = Layer1.loadProjectsFromSystemId(url, sourceSystemId, username, password,
//				returnInternalToDisplayMap);
//		return sourceSystemProjects;
//	}
//
//	public static HashMap<String, String> getTargetSystemProjects(String url, int targetSystemId, String username,
//			String password, boolean returnInternalToDisplayMap) throws Exception {
//		LOGGER.debug("Fetching projects from system id: " + targetSystemId);
//		if (targetSystemProjects != null) {
//			LOGGER.debug("Projects are already loaded, hence not loading again. Returning projects");
//			return targetSystemProjects;
//		}
//		targetSystemProjects = Layer1.loadProjectsFromSystemId(url, targetSystemId, username, password,
//				returnInternalToDisplayMap);
//		return targetSystemProjects;
//	}
	
	

	public static String getJiraBaseURL() {
		return integrationDetails.getProperty("JiraBaseURL");
	}

	public static String getJiraUserName() {
		return integrationDetails.getProperty("JiraUsername");
	}
	public static String getJiraPassword() {
		return integrationDetails.getProperty("JiraPassword");
	}
	
	public static String getADOBaseUrl() {
		return integrationDetails.getProperty("ADOBaseUrl");
	}
	public static String getADOUsername() {
		return integrationDetails.getProperty("ADOUsername");
	}

	public static String getADOPassword() {
		return integrationDetails.getProperty("ADOPassword");
	}

	/*
	 * public static HashMap<String, String> getAllTargetProjects(String
	 * baseUrl,String username, String password) {
	 * LOGGER.debug("Getting All Projects for Url:" + baseUrl); HashMap<String,
	 * String> targetProjectsIdKeyMap = new HashMap<>(); String url = baseUrl +
	 * "/rest/api/2/project"; // String username = getJiraUsername(); // String
	 * password = getJiraPassword(); String auth = username + ":" + password; byte[]
	 * encodedAuth =
	 * Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
	 * String authHeader = "Basic " + new String(encodedAuth); HashMap<String,
	 * String> headers = new HashMap<>(); headers.put("Authorization", authHeader);
	 * headers.put("Content-Type", "application/json"); String response =
	 * Layer1.sendJiraRequest(url, null, headers); try { JSONArray projectArray =
	 * new JSONArray(response); LOGGER.debug("Total Projects Found:" +
	 * projectArray.length()); if (projectArray == null || projectArray.length() ==
	 * 0) { LOGGER.debug(
	 * "No projects found. Please check whether user has permissions or credentials provided in the property file"
	 * ); } else { for (int i = 0; i < projectArray.length(); ++i) { JSONObject
	 * currentObj = projectArray.getJSONObject(i); String internalName =
	 * currentObj.getString("id"); String projectKey = currentObj.getString("key");
	 * targetProjectsIdKeyMap.put(internalName, projectKey); } } } catch
	 * (JSONException e) { LOGGER.error("Error occurred while converting to json");
	 * } return targetProjectsIdKeyMap; }
	 */
	
	
	public static HashMap<String, String> getAllSourceProjects(String baseUrl,String username, String password) {
		LOGGER.debug("Getting All Projects for Jira Url:" + baseUrl);
		HashMap<String, String> targetProjectsIdKeyMap = new HashMap<>();
		String url = baseUrl + "/rest/api/2/project";
//		String username = getJiraUsername();
//		String password = getJiraPassword();
		String auth = username + ":" + password;
		byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
		String authHeader = "Basic " + new String(encodedAuth);
		HashMap<String, String> headers = new HashMap<>();
		headers.put("Authorization", authHeader);
		headers.put("Content-Type", "application/json");
		String response = Layer1.sendJiraRequest(url, null, headers);
		try {
			JSONArray projectArray = new JSONArray(response);
			LOGGER.debug("Total Projects Found:" + projectArray.length());
			if (projectArray == null || projectArray.length() == 0) {
				LOGGER.debug(
						"No projects found. Please check whether user has permissions or credentials provided in the property file");
			} else {
				for (int i = 0; i < projectArray.length(); ++i) {
					JSONObject currentObj = projectArray.getJSONObject(i);
					String internalName = currentObj.getString("id");
					String projectKey = currentObj.getString("key");
					targetProjectsIdKeyMap.put(internalName, projectKey);
				}
			}
		} catch (JSONException e) {
			LOGGER.error("Error occurred while converting to json");
		}
		return targetProjectsIdKeyMap;
	}

	public static HashMap<String, String> getAllTargetProjects(String baseUrl,String username, String password) {
		LOGGER.debug("Getting All Projects for ADO Url:" + baseUrl);
		HashMap<String, String> targetProjectsIdKeyMap = new HashMap<>();
		String url = baseUrl + "/_apis/projects?api-version=6.0";
//		String username = getJiraUsername();
//		String password = getJiraPassword();
		String auth = username + ":" + password;
		byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
		String authHeader = "Basic " + new String(encodedAuth);
		HashMap<String, String> headers = new HashMap<>();
		headers.put("Authorization", authHeader);
		headers.put("Content-Type", "application/json");
		String response = Layer1.sendADORequest(url, null, headers);
		try {
			JSONArray projectArray = new JSONArray(response);
			LOGGER.debug("Total Projects Found:" + projectArray.length());
			if (projectArray == null || projectArray.length() == 0) {
				LOGGER.debug(
						"No projects found. Please check whether user has permissions or credentials provided in the property file");
			} else {
				for (int i = 0; i < projectArray.length(); ++i) {
					JSONObject currentObj = projectArray.getJSONObject(i);
					String internalName = currentObj.getString("name");
					String projectKey = currentObj.getString("id");
					targetProjectsIdKeyMap.put(internalName, projectKey);
				}
			}
		} catch (JSONException e) {
			LOGGER.error("Error occurred while converting to json");
		}
		return targetProjectsIdKeyMap;
	}
	
	
	public static boolean validateExcelProjects(List<ExcelInfo> excelProjects, String url, String username,
			String password, int currentPod) throws Exception {
		Layer1.loginAndSetValues(url, username, password);
		//HashMap<String, String> allSourceProjects = getAllSourceProjects(getJiraBaseURL(),getJiraUserName(),getJiraPassword());
		//HashMap<String, String> allTargetProjects = getAllTargetProjects(getADOBaseUrl(),getADOUsername(),getADOPassword());
		List<String> sourceNotFoundProjects = new ArrayList<>();
		List<String> targetNotFoundProjects = new ArrayList<>();
		List<String> sourceMoreThanOneFoundProjects = new ArrayList<>();
		List<String> targetMoreThanOneFoundProjects = new ArrayList<>();
		boolean globalValidation = true;
		for (ExcelInfo info : excelProjects) {
			String excelSourceProject = info.getSourceProject();
			String excelTargetProject = info.getTargetProject();
			String sourceSystem = info.getSourceSystemName();
			//String targetProjectExcelKey = info.getJiraProjectKey();
			//String sourceProjectExcelKey = info.getJiraSourceProjectKey();
			Integer sourceSystemId = Layer1.getSystemIdFromName(sourceSystem, url, username, password);
			Integer targetSystemId = getTargetSystemId(url, username, password);
			// internal to display name map

			HashMap<String, String> sourceSystemProjects = getProjectsFromSystemId(sourceSystemId, url, username,
					password, true, currentPod,true);
			HashMap<String, String> targetSystemProjects = getProjectsFromSystemId(targetSystemId, url, username,
					password, true, currentPod,false);
			//check input project exists or not, if yes add into excelNameSourceFullNameMap
			int foundProjectCount = 0;
			LOGGER.debug("Validating Source Project:" + excelSourceProject);
			
		
			
			
			 if(sourceSystemProjects.containsValue(excelSourceProject))
			 {
				 for (HashMap.Entry<String,String> entry : sourceSystemProjects.entrySet())
					{
						if(excelSourceProject.equals(entry.getValue()))
						{
							excelNameSourceFullNameMap.put(excelSourceProject, entry.getKey());
							break;
						}
					} 
			 }
			
			 
			 
			 if(targetSystemProjects.containsValue(excelTargetProject))
			 {
				 for (HashMap.Entry<String,String> entry : targetSystemProjects.entrySet())
					{
						if(excelTargetProject.equals(entry.getValue()))
						{
							excelNameTargetFullNameMap.put(excelTargetProject, entry.getKey());
							break;
						}
					} 
			 }

			
			
		//	globalValidation = validateProjects(allSourceProjects, sourceNotFoundProjects, sourceMoreThanOneFoundProjects,
		//			globalValidation, excelSourceProject, sourceSystemProjects,
			//		foundProjectCount,true);
			foundProjectCount = 0;
			LOGGER.debug("Validating Target Project:" + excelTargetProject);
		//	globalValidation = validateProjects(allJiraProjects, targetNotFoundProjects, targetMoreThanOneFoundProjects,
		//			globalValidation, excelTargetProject, targetProjectExcelKey, targetSystemProjects,
		//			foundProjectCount,false);
		}
		LOGGER.debug("Validation result for POD:" + currentPod);
		LOGGER.debug("Not Found In Source:" + sourceNotFoundProjects.toString());
		LOGGER.debug("Not Found In Target:" + targetNotFoundProjects.toString());
		LOGGER.debug("More Than One Found In Source:" + sourceMoreThanOneFoundProjects.toString());
		LOGGER.debug("More Than One Found In Target:" + targetMoreThanOneFoundProjects.toString());
		return globalValidation;
	}

	private static boolean validateProjects(HashMap<String, String> targetProjects, List<String> targetNotFoundProjects,
			List<String> targetMoreThanOneFoundProjects, boolean globalValidation, String excelTargetProject,
			 HashMap<String, String> targetSystemProjects, int foundProjectCount, boolean isSource) {
		boolean targetProjectFound = false;
		String targetProjectName = null;
		for (Map.Entry<String, String> target : targetSystemProjects.entrySet()) {
			targetProjectName = target.getValue();

			String internalName = target.getKey();
			String fetchedJiraKey = targetProjects.get(internalName);

			if (targetProjectName.equalsIgnoreCase(excelTargetProject)) {
				LOGGER.debug("Excel Project Name:" + excelTargetProject + " Excel Project Key:"
						+ " Fetched Project Name:" + targetProjectName
						+ " Fetched Project Key:" + fetchedJiraKey);
 	//	 if (fetchedJiraKey != null && fetchedJiraKey.equalsIgnoreCase(targetProjectExcelKey)) {
					targetProjectFound = true;
	//				foundProjectCount++;
	//			LOGGER.debug("EXISTS: Excel Project Name:" + excelTargetProject + " Excel Project Key:"+ targetProjectExcelKey +"Internal Name:"
	//						+ internalName + " Display Name:" + targetProjectName + "Fetched Jira Key: "+ fetchedJiraKey);
	//				if(isSource) {
	//					excelNameSourceFullNameMap.put(fetchedJiraKey, internalName);
	//				}
	//				else {
	//					excelNameTargetFullNameMap.put(fetchedJiraKey, internalName);
	//				}
	//				
	//			}
			}
		}
		if (!targetProjectFound) {
	//		LOGGER.debug("NOT FOUND Target Project:" + excelTargetProject+" - "+targetProjectExcelKey);
			globalValidation = false;
	//		targetNotFoundProjects.add(excelTargetProject+" - "+targetProjectExcelKey);
		}
		if (foundProjectCount > 1) {
	//		LOGGER.debug("MORE THAN ONE FOUND Target Project:" + excelTargetProject+" - "+targetProjectExcelKey);
			globalValidation = false;
	//		targetMoreThanOneFoundProjects.add(excelTargetProject+" - "+targetProjectExcelKey);
		}
		return globalValidation;
	}

	

	@SuppressWarnings("unchecked")
	private static Map<String, Object> getMapFromObject(final Object obj) {
		ObjectMapper mapper = new ObjectMapper();
		return mapper.convertValue(obj, Map.class);
	}

	static Integer getSourceSystemId(String url, String username, String password) throws Exception {
		String sourceSystemName = integrationDetails.getProperty(SOURCE_SYSTEM_NAME_KEY);
		LOGGER.debug("Source System Name: " + sourceSystemName);
		return Layer1.getSystemIdFromName(sourceSystemName, url, username, password);
	}

	static Integer getTargetSystemId(String url, String username, String password) throws Exception {
		String targetSystemName = integrationDetails.getProperty(TARGET_SYSTEM_NAME_KEY);
		LOGGER.debug("Target System Name: " + targetSystemName);
		return Layer1.getSystemIdFromName(targetSystemName, url, username, password);
	}

	static String[] getSourceProjects() {
		return integrationDetails.getProperty(SOURCE_PROJECT_KEY).split(",");
	}

	static String[] getTargetProjects() {
		return integrationDetails.getProperty(TARGET_PROJECT_KEY).split(",");
	}

	static String[] getMappingIds(int groupNo, String url, String username, String password) throws Exception {
		LOGGER.debug("Fetching mapping ids");
		String[] mappingNames = integrationDetails.getProperty(MAPPING_NAME + groupNo).split(",");
		String[] mappingIds = new String[mappingNames.length];
		for (int i = 0; i < mappingNames.length; ++i) {
			mappingIds[i] = String.valueOf(Layer1.getMappingIdFromName(mappingNames[i], url, username, password));
			LOGGER.debug("Mapping Name: " + mappingNames[i] + " Mapping id: " + mappingIds[i]);
		}
		return mappingIds;
	}

	static String[] getSourceIssueTypes(final int groupNo) {

		return integrationDetails.getProperty(SOURCE_ISSUE_TYPE_KEY + String.valueOf(groupNo)).split(",");
	}

	static String[] getTargetIssueTypes(final int groupNo) {
		return integrationDetails.getProperty(TARGET_ISSUE_TYPE_KEY + String.valueOf(groupNo)).split(",");
	}

	static String getPollingTime() {
		return integrationDetails.getProperty(POLLING_TIME);
	}

	static String[] getPollingTypes(final int groupNo) {
		return integrationDetails.getProperty(POLLING_TYPE + groupNo).split(",");
	}

	static int getStartCount(final int groupNo) {
		return Integer.parseInt(integrationDetails.getProperty(START_COUNT + groupNo));
	}

	static int getEndCount(final int groupNo) {
		return Integer.parseInt(integrationDetails.getProperty(END_COUNT + groupNo));
	}

	static Integer getScheduleId(final int groupNo, final int index) {
		String[] scheduleIds = integrationDetails.getProperty(SCHEDULE_ID_KEY + groupNo).split(",");
		return Integer.parseInt(scheduleIds[index]);
	}

	static Boolean getIsSearchInTarget(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty("searchInTarget" + groupNo));
	}

	static String getSearchQuery(int groupNo) {
		return integrationDetails.getProperty("searchQuery" + groupNo);
	}

	static String getIfMultipleFoundInTarget(int groupNo) {
		return integrationDetails.getProperty("ifMultipleInTarget" + groupNo);
	}

	static String getIsContinueSync(int groupNo) {
		return integrationDetails.getProperty("continueSync" + groupNo);
	}

	static String getIfNoEntityFound(int groupNo) {
		return integrationDetails.getProperty("ifNoEntityFound" + groupNo);
	}
	
	static Boolean getIsCriteriaEnabled(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty(ENABLE_CRITERIA + groupNo));
	}
	static String getAdditionalData(int groupNo) {
		return integrationDetails.getProperty(ADDITIONAL_DATA + groupNo);
	}
	static Boolean getIsCheckSourceEntityCountEnabled(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty(CHECK_SOURCE_ENTITY_COUNT + groupNo));
	}
	static String getTargetRemoteLink(int groupNo) {
		return integrationDetails.getProperty(REMOTE_LINK + groupNo);
	}
	static String getTargetRemoteEntityId(int groupNo) {
		return integrationDetails.getProperty(REMOTE_ID + groupNo);
	}
	static String getCriteriaQuery(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_QUERY + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_QUERY + String.valueOf(groupNo)).trim():"";
	}
	static String getCriteriaStorage(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_STORAGE + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_STORAGE + String.valueOf(groupNo)).trim():"";
	}
	static String getCriteriaStorageFieldName(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_STORAGE_FIELD + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_STORAGE_FIELD + String.valueOf(groupNo)).trim():"";
	}

	
	

	

	static void activateReconcileIds(List<Integer> reconcileIds, String url, String username, String password)
			throws Exception {
		LOGGER.debug("Activating reconcile ids: " + reconcileIds.toString());
		if (getActiveAfterCreation()) {
			StringBuilder sb = new StringBuilder("");
			for (int i = 0; i < reconcileIds.size(); ++i) {
				sb.append(String.valueOf(reconcileIds.get(i)));
				if (i != reconcileIds.size() - 1) {
					sb.append(",");
				}
			}

			LOGGER.debug("activeAfterCreate is enabled. Activating reconciliation: " + sb.toString());
			String requestBody = "{\"query\": \"mutation{actionHandler(action:\\\"status\\\",entity:\\\"reconcile\\\",ids:["
					+ sb.toString() + "],value:\\\"Run\\\"){result}}\"}";
			System.out.println(requestBody);
			Layer1.activateReconciliation(url, username, password, requestBody);
		} else {
			LOGGER.debug("activeAfterCreate is false, hence not activating reconciliation");
		}
	}

	public static void getAndSaveMappingDetails(String url, String username, String password, int mappingId)
			throws Exception {
		Mapper mapper = Layer1.getMappingDetailsForReconcile(url, username, password, mappingId);
		mapper.setTransitionConfig(new MapperTransitionConfig());
		List<MapperFieldConfig> fields = mapper.getFields();
		for (MapperFieldConfig field : fields) {
			MapperFieldSettings forwardSetting = field.getForwardSettings();
			RuleItem reconcileRule = new RuleItem();
			reconcileRule.setForCreate(true);
			reconcileRule.setForUpdate(true);
			reconcileRule.setMismatchStrategy("Source");
			forwardSetting.setReconcileRule(reconcileRule);
		}
		Map<String, Object> requestMap = getMapFromObject(mapper);
		String body = getMutationArgQuery(requestMap);
		StringBuilder requestBody = new StringBuilder("");
		requestBody.append("{\"query\": \"mutation{mapper(request : {");
		requestBody.append(body);
		requestBody.append(
				"}){response{mappingId,validationResult{endPoint1Name,endPoint2Name ,invalidFieldsData{key,invalidFields},invalidEnumsData{endPoint1FieldDisplayName,endPoint2FieldDisplayName,missingEndPoint1Enum,invalidEnums},confirmRuleDelete}}}}\"}");
		Layer1.saveReconcileRules(url, username, password, requestBody.toString());
	}

	static String getReconcileFolderName() {
		return reconcileDetails.getProperty("folderName");
	}

	static String getReconcileSourceIssueType() {
		return reconcileDetails.getProperty("sourceIssueType");
	}

	static String getReconcileTargetIssueType() {
		return reconcileDetails.getProperty("targetIssueType");
	}
	static String getReconcileWorkflowId() {
		return (reconcileDetails.getProperty("reconcileWorkflowId")==null || reconcileDetails.getProperty("reconcileWorkflowId").isEmpty())?String.valueOf(DEFAULT_RECONCILE_WORKFLOW_ID):reconcileDetails.getProperty("reconcileWorkflowId");
	}

	static boolean getActiveAfterCreation() {
		return Boolean.parseBoolean(reconcileDetails.getProperty("activeAfterCreate"));
	}

	static String getFolderName(String folderPrefix, int groupNo) {
		String postFix = integrationDetails.getProperty(PARENT_FOLDER_PATH_KEY + groupNo);
		boolean doOverwrite = Boolean.parseBoolean(integrationDetails.getProperty("overwriteFolder" + groupNo));
		if (doOverwrite && postFix != null && !postFix.isEmpty()) {
			LOGGER.debug("Overwrite is true for group no:" + groupNo + " for folder name. Hence returning:Default/"
					+ postFix);
			return "Default/" + postFix;
		}
		String folderName = folderPrefix + "/" + postFix;
		LOGGER.debug("Generated folder name:" + folderName);
		return folderName;
	}

	public static void loadReconcileProperties() throws Exception {
		LOGGER.debug("Loading properties for reconciliation from: " + RECONCILE_DETAILS_FILE);
		InputStream inputStream = null;
		try {
			reconcileDetails = new Properties();
			inputStream = Layer2.class.getClassLoader().getResourceAsStream(RECONCILE_DETAILS_FILE);
			reconcileDetails.load(inputStream);
		} catch (Exception e) {
			LOGGER.error(
					"Failed to load properties from " + RECONCILE_DETAILS_FILE + " file. Caused by: " + e.getMessage());
			throw new Exception(
					"Failed to load properties from " + RECONCILE_DETAILS_FILE + " file. Caused by: " + e.getMessage());
		}
	}

	static int getParentFolder(final String folderName, String url, String username, String password) throws Exception {
		int prevId = 0;
		try {
			String[] folders = folderName.split("/");
			for (int i = 1; i < folders.length; ++i) {
				int currentFolderId = Layer1.getFolderIdByName(url, folders[i], prevId, username, password);
				if (currentFolderId == -1) {
					LOGGER.debug("Folder does not exist: " + folders[i] + ". Hence creating..");
					int createdFolderId = Layer1.createFolder(url, folders[i], prevId, username, password);
					LOGGER.debug("Created folder with id: " + createdFolderId);
					prevId = createdFolderId;
				} else {
					prevId = currentFolderId;
				}
			}

		} catch (Exception e) {
			LOGGER.error("Error occurred while creating folder:" + folderName + " . Caused by: " + e.getMessage());
			throw new Exception("Error occurred getting/creating folder: " + folderName);
		}

		return prevId;
	}

	static String getMutationArgQuery(final Map<String, Object> map) {
		List<String> keyValuePair = new ArrayList<>();
		for (Map.Entry<String, Object> obj : map.entrySet()) {
			if (obj.getValue() == null) {
				// Skip fields which having value null on mutation query
				continue;
			}
			StringBuilder strKeyValue = new StringBuilder();
			strKeyValue.append(obj.getKey());
			strKeyValue.append(":");
			if (obj.getValue() instanceof Integer || obj.getValue() instanceof Long) {
				strKeyValue.append(obj.getValue());
			} else if (obj.getValue() instanceof Boolean) {
				strKeyValue.append(String.valueOf(obj.getValue()));
			} else if (obj.getValue() instanceof String) {
				strKeyValue.append("\\\"");
				String valueAsStr = escapeString(String.valueOf(obj.getValue()));
				strKeyValue.append(valueAsStr.replace("\"", "\\\""));
				strKeyValue.append("\\\"");
			} else if (obj.getValue() instanceof List) {
				List<Map<String, Object>> map1 = (List<Map<String, Object>>) obj.getValue();
				List<String> listStrings = new ArrayList<>();
				for (Object listObj : map1) {
					if (listObj instanceof Map) {
						listStrings.add("{" + getMutationArgQuery((Map<String, Object>) listObj) + "}");
					} else if (listObj instanceof Integer) {
						listStrings.add(escapeString(String.valueOf(listObj)));
					} else if (listObj instanceof String) {
						listStrings.add("\\\"" + escapeString(String.valueOf(listObj)) + "\\\"");
					} else {
						throw new RuntimeException(
								"This datatype is not yet supported in Automation Mutation Query Builder.");
					}
				}
				strKeyValue.append("[");
				if (listStrings.size() > 0) {
					strKeyValue.append(String.join(",", listStrings));
				}
				strKeyValue.append("]");

			} else if (obj.getValue() instanceof Map) {
				strKeyValue.append("{");
				strKeyValue.append(getMutationArgQuery((Map<String, Object>) obj.getValue()));
				strKeyValue.append("}");
			}
			keyValuePair.add(strKeyValue.toString());
		}
		return String.join(",", keyValuePair);
	}

	static String escapeString(final String string) {
		return string.replace("\n", "\\\\n").replace("\r", "\\\\r").replace("\"", "\\\\\"");
	}

}
