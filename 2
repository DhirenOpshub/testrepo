package layer2;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Random;

import org.apache.log4j.Logger;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellUtil;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import layer1.Layer1;
import layer4.ExcelInfo;
import layer4.IntegrationGroupData;

public class Layer2 {

	private static final String INTEGRATION_DETAILS_FILE = "IntegrationDetails2.properties";
	private static final String RECONCILE_DETAILS_FILE = "ReconciliationDetails2.properties";

	private static final String SOURCE_SYSTEM_NAME_KEY = "sourceSystemName";
	private static final String TARGET_SYSTEM_NAME_KEY = "targetSystemName";
	private static final String TOTAL_GROUP_KEY = "totalGroups";
	private static final String START_COUNT_PREFIX = "startCount";
	private static final String END_COUNT_PREFIX = "endCount";
	private static final String CREATE_EVENT_NAME = "Create";
	private static final String UPDATE_EVENT_NAME = "Update";
	private static final String DELETE_EVENT_NAME = "Delete";
	private static final Integer DEFAULT_INTEGRATION_WORKFLOW_ID = 1;
	private static final String SCHEDULE_ID_KEY = "scheduleId";
	private static final String START_COUNT = "startCount";
	private static final String END_COUNT = "endCount";
	private static final String POLLING_TIME = "pollingTime";
	private static final String SOURCE_ISSUE_TYPE_KEY = "sourceIssueTypes";
	private static final String TARGET_ISSUE_TYPE_KEY = "targetIssueTypes";
	private static final String SOURCE_PROJECT_KEY = "sourceProjects";
	private static final String TARGET_PROJECT_KEY = "targetProjects";
	private static final String POLLING_TYPE = "pollingType";
	private static final String PARENT_FOLDER_PATH_KEY = "parentFolderPath";
	private static final String MAPPING_NAME = "mappingName";
	private static final String NAME_POSTFIX = "postFixName";
	public static final String ENABLE_CRITERIA = "enable_criteria";
	public static final String ADDITIONAL_DATA = "additional_data";
	public static final String CHECK_SOURCE_ENTITY_COUNT = "check_source_entity_count";
	public static final String REMOTE_LINK = "remote_link";
	public static final String REMOTE_ID = "remote_id";
	public static final String CRITERIA_QUERY = "criteria_query";
	public static final String CRITERIA_STORAGE = "criteria_storage";
	public static final String CRITERIA_STORAGE_FIELD = "criteria_storage_field";

	private static final int DEFAULT_RECONCILE_WORKFLOW_ID = 24;

	private static final String CURRENT_STATE_FLAG = "1";

	private static final int PROJECT_ID_COL_INDEX = 1;
	private static final int WORKSPACE_ID_COL_INDEX = 0;
	private static final int SOURCE_PROJECT_COL_INDEX = 2;
	private static final int TARGET_PROJECT_COL_INDEX = 3;
	private static final int JIRA_PROJ_KEY_COL_INDEX = 4;
	private static final int INTEGRATION_NAME_COL_INDEX = 5;
	private static final int INTEGRATION_GROUP_ID_COL_INDEX = 6;
	private static final int FOLDER_ID_COL_INDEX = 7;
	private static final int FOLDER_PATH_COL_INDEX = 8;
	private static final int PROD_URL_COL_INDEX = 9;
	private static final int MILESTONE_ID_COL_INDEX = 10;
	private static final int RELEASE_ID_COL_INDEX = 11;
	private static final int ITERATION_ID_COL_INDEX = 12;
	private static final int DEFECT_ID_COL_INDEX = 13;
	private static final int USER_STORY_ID_COL_INDEX = 14;
	private static final int FEATURE_ID_COL_INDEX = 15;
	private static final int INITIATIVE_ID_COL_INDEX = 16;
	private static final int TASK_ID_COL_INDEX = 17;
	private static final int MINIMUM_BUS_INC_COL_INDEX = 18;

	private static final String[] BASIC_INTEGRATION_DETAIL_HEADER = new String[] { "Rally Workspace ID",
			"Rally Project ID", "Rally Project Name", "Jira Project Name", "Jira Project Key", "Integration Name",
			"Group Id", "Folder ID", "Folder Path", "Production URL" };
	
	private static final String[] JIRA_ISSUE_TYPE = new String[] { "Story","Task","Bug","Epic" };

	private static final Logger LOGGER = Logger.getLogger(Layer2.class);

	private static Properties integrationDetails = new Properties();
	private static Properties reconcileDetails;
	private static int[] projectStartCount;
	private static int[] projectEndCount;
	private static int totalGroups;

	private static HashMap<String, String> sourceSystemProjects = null;
	private static HashMap<String, String> targetSystemProjects = null;

	private static HashMap<String, String> excelNameSourceFullNameMap = new HashMap<>();
	private static HashMap<String, String> excelNameTargetFullNameMap = new HashMap<>();

	private static HashMap<Integer, int[]> podToStartCountMap = new HashMap<>();
	private static HashMap<Integer, int[]> podToEndCountMap = new HashMap<>();

	// using it as cache to store projects by system id
	private static HashMap<Integer, HashMap<Integer, HashMap<String, String>>> systemIdProjectMap = new HashMap<>();

	static {
		InputStream inputStream = null;
		try {
			inputStream = Layer2.class.getClassLoader().getResourceAsStream(INTEGRATION_DETAILS_FILE);
			integrationDetails.load(inputStream);
		} catch (Exception e) {
			LOGGER.error("Failed to load properties from " + INTEGRATION_DETAILS_FILE
					+ " file. Please make sure that the file exists or group information is provided properly. Caused by: "
					+ e.getMessage());
		}
	}

	public static void resetProperties(int totalProds, int currentPod) throws Exception {
		try {
			totalGroups = Integer.parseInt(integrationDetails.getProperty(TOTAL_GROUP_KEY));
			projectStartCount = new int[totalGroups];
			projectEndCount = new int[totalGroups];
			for (int i = 0; i < totalGroups; ++i) {
				projectStartCount[i] = Integer.parseInt(integrationDetails.getProperty(START_COUNT_PREFIX + (i + 1)));
				projectEndCount[i] = Integer.parseInt(integrationDetails.getProperty(END_COUNT_PREFIX + (i + 1)));
			}
			podToStartCountMap.put(currentPod, projectStartCount);
			podToEndCountMap.put(currentPod, projectEndCount);
		} catch (Exception e) {
			LOGGER.error("Exception error occurred because of " + e.getMessage());
			throw new Exception("Error occurred while reseting properties.");
		}

	}

	public static void createIntegration(List<ExcelInfo> excelProjects, String url, String username,
			final String password, final int totalProds, final int currentPod) throws Exception {

		if (excelProjects == null || excelProjects.isEmpty()) {
			LOGGER.debug("No projects are mentioned for prod:" + currentPod + ". Moving to the next Prod.");
			return;
		}

		LOGGER.debug("Creating integrations in pod: " + currentPod);

		String createIntegrationUrl = url;
		resetProperties(totalProds, currentPod);
		for (int groupNo = 1; groupNo <= totalGroups; ++groupNo) {
			
			IntegrationGroupData integrationData = new IntegrationGroupData();
			int[] startCount = podToStartCountMap.get(currentPod);
			int[] endCount = podToEndCountMap.get(currentPod);
			LOGGER.debug("Production Instance:" + currentPod + " Group No:" + groupNo + " StartCount:"
					+ startCount[groupNo - 1] + " EndCount:" + endCount[groupNo - 1] + " Excel projects for this prod:"
					+ excelProjects.size());
			int remainingExcelProjects = excelProjects.size();
			while (startCount[groupNo - 1] <= endCount[groupNo - 1] && remainingExcelProjects > 0) {
				try {
					LOGGER.debug("Group:" + groupNo + " Start Count:" + startCount[groupNo - 1] + " End Count:"
							+ endCount[groupNo - 1] + " Remaining Projects From Excel: " + remainingExcelProjects);
					remainingExcelProjects--;
					IntegrationGroupInfo groupInfo = getIntegrationGroupInfo(groupNo, excelProjects, url, username, password,
							currentPod, integrationData);
					String requestBody = getRequestBody(groupNo, url, username, password, currentPod, groupInfo);
					integrationData.setProductionUrl(createIntegrationUrl);
					String integrationGroupName = groupInfo.getProjectMapping().get(0).getEp1Project();
					LOGGER.debug("IntegrationGroupName" +integrationGroupName);
//					long workspaceId = Long
//							.parseLong(integrationGroupName.substring(0, integrationGroupName.indexOf("::")));
//					long projectId = Long
//							.parseLong(integrationGroupName.substring(integrationGroupName.indexOf("::::") + 4));
//					integrationData.setWorkspaceId(workspaceId);
//					integrationData.setProjectId(projectId);
					String response = Layer1.createIntegration(createIntegrationUrl, username, password, requestBody);
					startCount[groupNo - 1]++;
					podToStartCountMap.put(currentPod, startCount);
					if (response != null) {
						try {
							JSONObject apiJsonResponse = new JSONObject(response);
							JSONObject integrationGroupSchema = apiJsonResponse.getJSONObject("integrationGroupSchema");
							JSONObject integrationGroupSchemaResponse = integrationGroupSchema.getJSONObject("response");
							int integrationGroupId = integrationGroupSchemaResponse.getInt("groupId");
							LOGGER.debug(
									"-----------------------------------------------------------------------------------------");
							LOGGER.debug("Integration " + groupInfo.getGroupName()
									+ " is created successfully with group id:" + integrationGroupId);
							LOGGER.debug(
									"-----------------------------------------------------------------------------------------");
							integrationData.setIntegrationGroupId(integrationGroupId);
							JSONObject integrationIdsByGroup = getIntegrationDetailsFromGroupId(createIntegrationUrl,
									username, password, groupInfo.getParentFolderId(), integrationGroupId);

							JSONArray integrationList = integrationIdsByGroup.getJSONObject("integrationList")
									.getJSONArray("list");
							String sourceProjectInternalName = groupInfo.getProjectMapping().get(0).getEp1Project();
							HashMap<String, String> sourceProjectIssueTypes = Layer1
									.getCachedSourceProjectIssueTypes(sourceProjectInternalName);
							for (int i = 0; i < integrationList.length(); ++i) {
								JSONObject forwardSettings = integrationList.getJSONObject(i)
										.getJSONObject("forwardSettings");
								String sourceIssueType = forwardSettings.getJSONObject("sourceContext")
										.getString("issueType");
								int unidirectionId = forwardSettings.getInt("unidirectionalId");

								for (Map.Entry<String, String> entry : sourceProjectIssueTypes.entrySet()) {
									String internalName = entry.getValue();
									if (sourceIssueType.equals(internalName)) {
										String displayName = entry.getKey();
										if (displayName.equalsIgnoreCase("Story")) {
											integrationData.setStoryId(unidirectionId);
										} else if (displayName.equals("Task")) {
											integrationData.setTaskId(unidirectionId);
										} else if (displayName.equalsIgnoreCase("Bug")) {
											integrationData.setBugId(unidirectionId);
										} else if (displayName.equalsIgnoreCase("Epic")) {
											integrationData.setEpicId(unidirectionId);
										}else {
											// do nothing
										}
									}
								}
							}
							printDataToExcel(integrationData);
						} catch (JSONException jse) {
							LOGGER.error("Error occurred while converting integration group: " + groupInfo.getGroupName()
									+ " response to json");
							throw new Exception("Error occurred while creating integration: " + jse.getMessage());
						} catch (Exception e) {
							LOGGER.error("Error occurred while creating integration group:" + groupInfo.getGroupName());
						}
					} else {
						LOGGER.error("Error occurred while creating integrations: " + groupInfo.getGroupName()
								+ " Response is null");
					}
					LOGGER.debug(
							"-------------------------------------------------------------------------------------------------------------");
				}catch(Exception e) {
					if(e.getMessage().contains("Could not find internal name for issue type")) {	
						startCount[groupNo - 1]++;
						LOGGER.debug(
								"-------------------------------------------------------------------------------------------------------------");
						LOGGER.debug("Skipping Integration creation as Issue Type not found");
						LOGGER.debug(
								"-------------------------------------------------------------------------------------------------------------");
					}else {
						throw e;
					}
				}
				
			}
		}
	}

	static void printDataToExcel(IntegrationGroupData integrationData) throws Exception {
		LOGGER.debug("Writing data to the excel file.");
		Workbook workbook = null;
		File outputFile = null;
		FileOutputStream outputStream = null;
		FileInputStream inputStream = null;
		String outputFileName = getOutputFileName();
		try {
			boolean doesFileExist = false;
			outputFile = new File(outputFileName);
			if (outputFile.exists()) {
				LOGGER.debug("Output file: " + outputFileName + " already exists, hence not creating new one.");
				doesFileExist = true;
				inputStream = new FileInputStream(outputFile);
				if (outputFileName.endsWith(".xlsx")) {
					workbook = new XSSFWorkbook(inputStream);
				} else if (outputFileName.endsWith(".xls")) {
					workbook = new HSSFWorkbook(inputStream);
				} else {
					// do nothing
				}

			} else {
				// create new
				LOGGER.debug("Output file does not exist. Hence creating:" + outputFileName);
				workbook = new XSSFWorkbook();
				Sheet sheet = workbook.createSheet(getOutputFileSheetName());
				Row firstRow = sheet.createRow(0);
				CellRangeAddress cellRangeAddress = new CellRangeAddress(0, 0, 0, 9);
				sheet.addMergedRegion(cellRangeAddress);
				Cell basicIntegrationCell = CellUtil.createCell(firstRow, 0, "Basic Intgeration Details");
				CellUtil.setAlignment(basicIntegrationCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 10, 18);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationDetailCell = CellUtil.createCell(firstRow, 10, "Integration Details");
				CellUtil.setAlignment(integrationDetailCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 19, 27);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationStatusCell = CellUtil.createCell(firstRow, 19, "Integration Status");
				CellUtil.setAlignment(integrationStatusCell, HorizontalAlignment.CENTER);

				cellRangeAddress = new CellRangeAddress(0, 0, 28, 36);
				sheet.addMergedRegion(cellRangeAddress);
				Cell integrationFailureCell = CellUtil.createCell(firstRow, 28, "Integration Failures");
				CellUtil.setAlignment(integrationFailureCell, HorizontalAlignment.CENTER);

				Row secondRow = sheet.createRow(1);
				int col = 0;
				for (int i = 0; i < BASIC_INTEGRATION_DETAIL_HEADER.length; ++i) {
					Cell currentCell = secondRow.createCell(i);
					currentCell.setCellValue(BASIC_INTEGRATION_DETAIL_HEADER[i]);
					col++;
				}
				for (int t = 1; t <= 3; ++t) {
					for (int i = 0; i < JIRA_ISSUE_TYPE.length; ++i) {
						Cell currentCell = secondRow.createCell(col);
						currentCell.setCellValue(JIRA_ISSUE_TYPE[i]);
						col++;
					}
				}

			}
			Sheet sheet = workbook.getSheet(getOutputFileSheetName());
			if (sheet != null) {
				LOGGER.debug("Writing to the file");
				int lastRow = sheet.getLastRowNum();
				Row row = sheet.createRow(lastRow + 1);
				Cell sourceProjectCell = row.createCell(SOURCE_PROJECT_COL_INDEX);
				sourceProjectCell.setCellValue(integrationData.getSourceProjectName());
				Cell targetProjectCell = row.createCell(TARGET_PROJECT_COL_INDEX);
				targetProjectCell.setCellValue(integrationData.getTargetProjectName());
				Cell integrationNameCell = row.createCell(INTEGRATION_NAME_COL_INDEX);
				integrationNameCell.setCellValue(integrationData.getIntegrationGroupName());
				Cell groupIdCell = row.createCell(INTEGRATION_GROUP_ID_COL_INDEX);
				groupIdCell.setCellValue(integrationData.getIntegrationGroupId());
				Cell folderIdCell = row.createCell(FOLDER_ID_COL_INDEX);
				folderIdCell.setCellValue(integrationData.getFolderId());
				Cell folderPathCell = row.createCell(FOLDER_PATH_COL_INDEX);
				folderPathCell.setCellValue(integrationData.getFolderPath());
				Cell productionUrlCell = row.createCell(PROD_URL_COL_INDEX);
				productionUrlCell.setCellValue(integrationData.getProductionUrl());
				Cell milestoneCell = row.createCell(MILESTONE_ID_COL_INDEX);
				//milestoneCell.setCellValue(integrationData.getMilestoneId());
				Cell releaseCell = row.createCell(RELEASE_ID_COL_INDEX);
			//	releaseCell.setCellValue(integrationData.getReleaseId());
				Cell iterationCell = row.createCell(ITERATION_ID_COL_INDEX);
			//	iterationCell.setCellValue(integrationData.getIterationId());
				Cell defectCell = row.createCell(DEFECT_ID_COL_INDEX);
			//	defectCell.setCellValue(integrationData.getDefectId());
				Cell userStoryCell = row.createCell(USER_STORY_ID_COL_INDEX);
				//userStoryCell.setCellValue(integrationData.getUserStoryId());
				Cell featureCell = row.createCell(FEATURE_ID_COL_INDEX);
		//		featureCell.setCellValue(integrationData.getFeatureId());
				Cell initiativeCell = row.createCell(INITIATIVE_ID_COL_INDEX);
	//			initiativeCell.setCellValue(integrationData.getInitiativeId());
				Cell taskCell = row.createCell(TASK_ID_COL_INDEX);
				taskCell.setCellValue(integrationData.getTaskId());
				Cell minimumBusCell = row.createCell(MINIMUM_BUS_INC_COL_INDEX);
		//		minimumBusCell.setCellValue(integrationData.getMinimumBusinessId());
				Cell workspaceCell = row.createCell(WORKSPACE_ID_COL_INDEX);
	//			workspaceCell.setCellValue(integrationData.getJiraSourceProjectKey());
				Cell projectCell = row.createCell(PROJECT_ID_COL_INDEX);
				projectCell.setCellValue(integrationData.getProjectId());
				Cell projectKeyCell = row.createCell(JIRA_PROJ_KEY_COL_INDEX);
	//			projectKeyCell.setCellValue(integrationData.getJiraProjectKey());
				for (int i = 19; i <= 21; ++i) {
					Cell statusCell = row.createCell(i);
					statusCell.setCellValue("1");
				}
				for (int i = 22; i <= 27; ++i) {
					Cell statusCell = row.createCell(i);
					statusCell.setCellValue("0");
				}
			} else {
				// throw exception
				LOGGER.error("Could not find the sheet name:" + getOutputFileSheetName());
				throw new Exception(
						"Could not find the sheet name: " + getOutputFileName() + " in file:" + getOutputFileName());
			}
			if (doesFileExist) {
				outputStream = new FileOutputStream(outputFile);
			} else {
				outputStream = new FileOutputStream(new File(getOutputFileName()));
			}
			workbook.write(outputStream);
		} catch (Exception e) {
			LOGGER.error("Error occurred while writing to the excel file. Caused by:" + e.getMessage());
			throw new Exception("Error occurred while writing to the output file. " + e.getMessage());
		} finally {
			if (workbook != null)
				workbook.close();
			if (outputStream != null)
				outputStream.close();
			if (inputStream != null)
				inputStream.close();
		}
	}

	static String getOutputFileName() {
		return integrationDetails.getProperty("outputFileName");
	}

	static String getOutputFileSheetName() {
		return integrationDetails.getProperty("outputSheetName");
	}

	static Integer getWorkflowId(int groupNo, int currentIndex) {
		String[] workflowIds = integrationDetails.getProperty("workflowIds" + groupNo).split(",");
		return Integer.parseInt(workflowIds[currentIndex]);
	}

	static List<EAISourceEventInfo> getEvents(final int groupNo, final String mappingId, int currentIndex)
			throws Exception {
		List<EAISourceEventInfo> events = new ArrayList<>();
		for (int i = 1; i <= 3; ++i) {
			EAISourceEventInfo event = new EAISourceEventInfo();
			if(i==3)
				event.setEventId(i+1);
			else
				event.setEventId(i);
			if (i == 1)
				event.setEventName(CREATE_EVENT_NAME);
			else if(i == 2)
				event.setEventName(UPDATE_EVENT_NAME);
			else
				event.setEventName(DELETE_EVENT_NAME);

			List<EAIProcessDefinfo> processDefList = new ArrayList<>();
			EAIProcessDefinfo processDef = new EAIProcessDefinfo();
			processDef.setActive(true);
			// workflow id

			int workflowId = getWorkflowId(groupNo, currentIndex);
			LOGGER.debug("Workflow id:" + workflowId);
			if (workflowId <= 0) {
				throw new Exception("Error occurred while setting workflow id. Workflow id:" + workflowId);
			}

			processDef.setProcessDefnId(workflowId);

			processDef.setEventProcessDefnId(-1);

			// mapping id
			processDef.setTransformations(Integer.parseInt(mappingId));

			processDefList.add(processDef);
			event.setProcessDefs(processDefList);
			events.add(event);
		}
		return events;
	}

	static IntegrationContext getIntegrationContext() {
		IntegrationContext integrationContext = new IntegrationContext();
		integrationContext.setPollingTime(getPollingTime());
		return integrationContext;
	}

	public static HashMap<String, String> getProjectsFromSystemId(int systemId, String url, String username,
			String password, boolean returnInternalToDisplayMap, int currentPod,Boolean isDoorsSystem) throws Exception {
		HashMap<Integer, HashMap<String, String>> currentPodSystemProjects = systemIdProjectMap.get(currentPod);
		if (currentPodSystemProjects != null && !currentPodSystemProjects.isEmpty()) {
			HashMap<String, String> systemProjects = currentPodSystemProjects.get(systemId);
			if (systemProjects != null && !systemProjects.isEmpty()) {
				LOGGER.debug("Projects are already loaded for system id:" + systemId + " with prod instance:"
						+ currentPod + ". Hence not loading again, returning projects...");
				return systemProjects;
			}
		}
		LOGGER.debug("************** Fetching projects for SystemID: " + systemId + "  **************");
		HashMap<String, String> fetchedProjects = Layer1.loadProjectsFromSystemId(url, systemId, username, password,
				returnInternalToDisplayMap,isDoorsSystem);
		HashMap<Integer, HashMap<String, String>> alreadyStoredProjects = systemIdProjectMap.get(currentPod);
		if (alreadyStoredProjects == null) {
			alreadyStoredProjects = new HashMap<>();
		}
		alreadyStoredProjects.put(systemId, fetchedProjects);
		systemIdProjectMap.put(currentPod, alreadyStoredProjects);
		return fetchedProjects;
	}

//	public static HashMap<String, String> getSourceSystemProjects(String url, int sourceSystemId, String username,
//			String password, boolean returnInternalToDisplayMap) throws Exception {
//		LOGGER.debug("Fetching projects from system id: " + sourceSystemId);
//		if (sourceSystemProjects != null) {
//			LOGGER.debug("Projects are already loaded, hence not loading again. Returning projects");
//			return sourceSystemProjects;
//		}
//		sourceSystemProjects = Layer1.loadProjectsFromSystemId(url, sourceSystemId, username, password,
//				returnInternalToDisplayMap);
//		return sourceSystemProjects;
//	}
//
//	public static HashMap<String, String> getTargetSystemProjects(String url, int targetSystemId, String username,
//			String password, boolean returnInternalToDisplayMap) throws Exception {
//		LOGGER.debug("Fetching projects from system id: " + targetSystemId);
//		if (targetSystemProjects != null) {
//			LOGGER.debug("Projects are already loaded, hence not loading again. Returning projects");
//			return targetSystemProjects;
//		}
//		targetSystemProjects = Layer1.loadProjectsFromSystemId(url, targetSystemId, username, password,
//				returnInternalToDisplayMap);
//		return targetSystemProjects;
//	}
	
	

	public static String getJiraBaseURL() {
		return integrationDetails.getProperty("JiraBaseURL");
	}

	public static String getJiraUserName() {
		return integrationDetails.getProperty("JiraUsername");
	}
	public static String getJiraPassword() {
		return integrationDetails.getProperty("JiraPassword");
	}
	
	public static String getADOBaseUrl() {
		return integrationDetails.getProperty("ADOBaseUrl");
	}
	public static String getADOUsername() {
		return integrationDetails.getProperty("ADOUsername");
	}

	public static String getADOPassword() {
		return integrationDetails.getProperty("ADOPassword");
	}

	/*
	 * public static HashMap<String, String> getAllTargetProjects(String
	 * baseUrl,String username, String password) {
	 * LOGGER.debug("Getting All Projects for Url:" + baseUrl); HashMap<String,
	 * String> targetProjectsIdKeyMap = new HashMap<>(); String url = baseUrl +
	 * "/rest/api/2/project"; // String username = getJiraUsername(); // String
	 * password = getJiraPassword(); String auth = username + ":" + password; byte[]
	 * encodedAuth =
	 * Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
	 * String authHeader = "Basic " + new String(encodedAuth); HashMap<String,
	 * String> headers = new HashMap<>(); headers.put("Authorization", authHeader);
	 * headers.put("Content-Type", "application/json"); String response =
	 * Layer1.sendJiraRequest(url, null, headers); try { JSONArray projectArray =
	 * new JSONArray(response); LOGGER.debug("Total Projects Found:" +
	 * projectArray.length()); if (projectArray == null || projectArray.length() ==
	 * 0) { LOGGER.debug(
	 * "No projects found. Please check whether user has permissions or credentials provided in the property file"
	 * ); } else { for (int i = 0; i < projectArray.length(); ++i) { JSONObject
	 * currentObj = projectArray.getJSONObject(i); String internalName =
	 * currentObj.getString("id"); String projectKey = currentObj.getString("key");
	 * targetProjectsIdKeyMap.put(internalName, projectKey); } } } catch
	 * (JSONException e) { LOGGER.error("Error occurred while converting to json");
	 * } return targetProjectsIdKeyMap; }
	 */
	
	
	public static HashMap<String, String> getAllSourceProjects(String baseUrl,String username, String password) {
		LOGGER.debug("Getting All Projects for Jira Url:" + baseUrl);
		HashMap<String, String> targetProjectsIdKeyMap = new HashMap<>();
		String url = baseUrl + "/rest/api/2/project";
//		String username = getJiraUsername();
//		String password = getJiraPassword();
		String auth = username + ":" + password;
		byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
		String authHeader = "Basic " + new String(encodedAuth);
		HashMap<String, String> headers = new HashMap<>();
		headers.put("Authorization", authHeader);
		headers.put("Content-Type", "application/json");
		String response = Layer1.sendJiraRequest(url, null, headers);
		try {
			JSONArray projectArray = new JSONArray(response);
			LOGGER.debug("Total Projects Found:" + projectArray.length());
			if (projectArray == null || projectArray.length() == 0) {
				LOGGER.debug(
						"No projects found. Please check whether user has permissions or credentials provided in the property file");
			} else {
				for (int i = 0; i < projectArray.length(); ++i) {
					JSONObject currentObj = projectArray.getJSONObject(i);
					String internalName = currentObj.getString("id");
					String projectKey = currentObj.getString("key");
					targetProjectsIdKeyMap.put(internalName, projectKey);
				}
			}
		} catch (JSONException e) {
			LOGGER.error("Error occurred while converting to json");
		}
		return targetProjectsIdKeyMap;
	}

	public static HashMap<String, String> getAllTargetProjects(String baseUrl,String username, String password) {
		LOGGER.debug("Getting All Projects for ADO Url:" + baseUrl);
		HashMap<String, String> targetProjectsIdKeyMap = new HashMap<>();
		String url = baseUrl + "/_apis/projects?api-version=6.0";
//		String username = getJiraUsername();
//		String password = getJiraPassword();
		String auth = username + ":" + password;
		byte[] encodedAuth = Base64.getEncoder().encode(auth.getBytes(StandardCharsets.ISO_8859_1));
		String authHeader = "Basic " + new String(encodedAuth);
		HashMap<String, String> headers = new HashMap<>();
		headers.put("Authorization", authHeader);
		headers.put("Content-Type", "application/json");
		String response = Layer1.sendADORequest(url, null, headers);
		try {
			JSONArray projectArray = new JSONArray(response);
			LOGGER.debug("Total Projects Found:" + projectArray.length());
			if (projectArray == null || projectArray.length() == 0) {
				LOGGER.debug(
						"No projects found. Please check whether user has permissions or credentials provided in the property file");
			} else {
				for (int i = 0; i < projectArray.length(); ++i) {
					JSONObject currentObj = projectArray.getJSONObject(i);
					String internalName = currentObj.getString("name");
					String projectKey = currentObj.getString("id");
					targetProjectsIdKeyMap.put(internalName, projectKey);
				}
			}
		} catch (JSONException e) {
			LOGGER.error("Error occurred while converting to json");
		}
		return targetProjectsIdKeyMap;
	}
	
	
	public static boolean validateExcelProjects(List<ExcelInfo> excelProjects, String url, String username,
			String password, int currentPod) throws Exception {
		Layer1.loginAndSetValues(url, username, password);
		//HashMap<String, String> allSourceProjects = getAllSourceProjects(getJiraBaseURL(),getJiraUserName(),getJiraPassword());
		//HashMap<String, String> allTargetProjects = getAllTargetProjects(getADOBaseUrl(),getADOUsername(),getADOPassword());
		List<String> sourceNotFoundProjects = new ArrayList<>();
		List<String> targetNotFoundProjects = new ArrayList<>();
		List<String> sourceMoreThanOneFoundProjects = new ArrayList<>();
		List<String> targetMoreThanOneFoundProjects = new ArrayList<>();
		boolean globalValidation = true;
		for (ExcelInfo info : excelProjects) {
			String excelSourceProject = info.getSourceProject();
			String excelTargetProject = info.getTargetProject();
			String sourceSystem = info.getSourceSystemName();
			//String targetProjectExcelKey = info.getJiraProjectKey();
			//String sourceProjectExcelKey = info.getJiraSourceProjectKey();
			Integer sourceSystemId = Layer1.getSystemIdFromName(sourceSystem, url, username, password);
			Integer targetSystemId = getTargetSystemId(url, username, password);
			// internal to display name map

			HashMap<String, String> sourceSystemProjects = getProjectsFromSystemId(sourceSystemId, url, username,
					password, true, currentPod,true);
			HashMap<String, String> targetSystemProjects = getProjectsFromSystemId(targetSystemId, url, username,
					password, true, currentPod,false);
			//check input project exists or not, if yes add into excelNameSourceFullNameMap
			int foundProjectCount = 0;
			LOGGER.debug("Validating Source Project:" + excelSourceProject);
			
		
			
			
			 if(sourceSystemProjects.containsValue(excelSourceProject))
			 {
				 for (HashMap.Entry<String,String> entry : sourceSystemProjects.entrySet())
					{
						if(excelSourceProject.equals(entry.getValue()))
						{
							excelNameSourceFullNameMap.put(excelSourceProject, entry.getKey());
							break;
						}
					} 
			 }
			
			 
			 
			 if(targetSystemProjects.containsValue(excelTargetProject))
			 {
				 for (HashMap.Entry<String,String> entry : targetSystemProjects.entrySet())
					{
						if(excelTargetProject.equals(entry.getValue()))
						{
							excelNameTargetFullNameMap.put(excelTargetProject, entry.getKey());
							break;
						}
					} 
			 }

			
			
		//	globalValidation = validateProjects(allSourceProjects, sourceNotFoundProjects, sourceMoreThanOneFoundProjects,
		//			globalValidation, excelSourceProject, sourceSystemProjects,
			//		foundProjectCount,true);
			foundProjectCount = 0;
			LOGGER.debug("Validating Target Project:" + excelTargetProject);
		//	globalValidation = validateProjects(allJiraProjects, targetNotFoundProjects, targetMoreThanOneFoundProjects,
		//			globalValidation, excelTargetProject, targetProjectExcelKey, targetSystemProjects,
		//			foundProjectCount,false);
		}
		LOGGER.debug("Validation result for POD:" + currentPod);
		LOGGER.debug("Not Found In Source:" + sourceNotFoundProjects.toString());
		LOGGER.debug("Not Found In Target:" + targetNotFoundProjects.toString());
		LOGGER.debug("More Than One Found In Source:" + sourceMoreThanOneFoundProjects.toString());
		LOGGER.debug("More Than One Found In Target:" + targetMoreThanOneFoundProjects.toString());
		return globalValidation;
	}

	private static boolean validateProjects(HashMap<String, String> targetProjects, List<String> targetNotFoundProjects,
			List<String> targetMoreThanOneFoundProjects, boolean globalValidation, String excelTargetProject,
			 HashMap<String, String> targetSystemProjects, int foundProjectCount, boolean isSource) {
		boolean targetProjectFound = false;
		String targetProjectName = null;
		for (Map.Entry<String, String> target : targetSystemProjects.entrySet()) {
			targetProjectName = target.getValue();

			String internalName = target.getKey();
			String fetchedJiraKey = targetProjects.get(internalName);

			if (targetProjectName.equalsIgnoreCase(excelTargetProject)) {
				LOGGER.debug("Excel Project Name:" + excelTargetProject + " Excel Project Key:"
						+ " Fetched Project Name:" + targetProjectName
						+ " Fetched Project Key:" + fetchedJiraKey);
 	//	 if (fetchedJiraKey != null && fetchedJiraKey.equalsIgnoreCase(targetProjectExcelKey)) {
					targetProjectFound = true;
	//				foundProjectCount++;
	//			LOGGER.debug("EXISTS: Excel Project Name:" + excelTargetProject + " Excel Project Key:"+ targetProjectExcelKey +"Internal Name:"
	//						+ internalName + " Display Name:" + targetProjectName + "Fetched Jira Key: "+ fetchedJiraKey);
	//				if(isSource) {
	//					excelNameSourceFullNameMap.put(fetchedJiraKey, internalName);
	//				}
	//				else {
	//					excelNameTargetFullNameMap.put(fetchedJiraKey, internalName);
	//				}
	//				
	//			}
			}
		}
		if (!targetProjectFound) {
	//		LOGGER.debug("NOT FOUND Target Project:" + excelTargetProject+" - "+targetProjectExcelKey);
			globalValidation = false;
	//		targetNotFoundProjects.add(excelTargetProject+" - "+targetProjectExcelKey);
		}
		if (foundProjectCount > 1) {
	//		LOGGER.debug("MORE THAN ONE FOUND Target Project:" + excelTargetProject+" - "+targetProjectExcelKey);
			globalValidation = false;
	//		targetMoreThanOneFoundProjects.add(excelTargetProject+" - "+targetProjectExcelKey);
		}
		return globalValidation;
	}

	public static IntegrationGroupInfo getIntegrationGroupInfo(int groupNo, List<ExcelInfo> excelProjects,
			String url, String username, String password, int currentPod, IntegrationGroupData integrationData)
			throws Exception {
		LOGGER.debug("Getting integration group information...");
		IntegrationGroupInfo info = new IntegrationGroupInfo();
		info.setGroupId(-1);

		int[] projectStartCountForCurrentPod = podToStartCountMap.get(currentPod);
		int startProjectNumberForCurrentGroup = projectStartCountForCurrentPod[groupNo - 1];

		String sourceProject = excelProjects.get(startProjectNumberForCurrentGroup - 1).getSourceProject();
		String targetProject = excelProjects.get(startProjectNumberForCurrentGroup - 1).getTargetProject();
		//String sourceProjectKey = excelProjects.get(startProjectNumberForCurrentGroup - 1).getJiraSourceProjectKey();
		//String targetProjectKey = excelProjects.get(startProjectNumberForCurrentGroup - 1).getJiraProjectKey();
		String sourceSystemName = excelProjects.get(startProjectNumberForCurrentGroup - 1).getSourceSystemName();
//		String excelCriteria = excelProjects.get(startProjectNumberForCurrentGroup - 1).getCriteria();
		String targetSystemName = integrationDetails.getProperty(TARGET_SYSTEM_NAME_KEY);
		
		int sourceSystemId = Layer1.getSystemIdFromName(sourceSystemName, url, username, password);
		int targetSystemId = Layer1.getSystemIdFromName(targetSystemName, url, username, password);
		info.setEndPoint1(sourceSystemId);
		info.setEndPoint2(targetSystemId);

		//String jiraProjectKey = excelProjects.get(startProjectNumberForCurrentGroup - 1).getJiraProjectKey();
		//integrationData.setJiraProjectKey(jiraProjectKey);

		
//		HashMap<String, String> sourceSystemProjectsInternalToDisplayMap = new HashMap<>(sourceSystemProjects);
//		HashMap<String, String> sourceDisplayInternalSystemProjects = new HashMap<>();
//		for (Map.Entry<String, String> entry : sourceSystemProjects.entrySet()) {
//			String internalName = entry.getKey();
//			String displayName = entry.getValue();
//			sourceDisplayInternalSystemProjects.put(displayName, internalName);
//		}
		
		ProjectMappingContext context = new ProjectMappingContext();
		LOGGER.debug("Setting EP1 Context: " + excelNameSourceFullNameMap.get(sourceProject));
		context.setEp1Project(excelNameSourceFullNameMap.get(sourceProject));
		integrationData.setSourceProjectName(sourceProject);
		LOGGER.debug("Setting EP2 Context: " + excelNameTargetFullNameMap.get(targetProject));
		integrationData.setTargetProjectName(targetProject);
		context.setEp2Project(excelNameTargetFullNameMap.get(targetProject));
		context.setDirection(ConfigDirection.FORWARD);
		List<ProjectMappingContext> projectMappingContext = new ArrayList<>();
		projectMappingContext.add(context);
		String postfixName = getIntegrationPostfixName(groupNo);
		String groupName;
		if (postfixName != null && !postfixName.isEmpty()) {
			groupName = sourceProject + " - " + targetProject + " " + postfixName + " ";
			groupName = groupName.replace("\\", "\\\\");
			
		} else {
			groupName = sourceProject + " - " + targetProject + " ";
			groupName = groupName.replace("\\", " ");
		}
//		if(excelCriteria!=null && !excelCriteria.isEmpty()) {
//			groupName = groupName + excelCriteria;
//		}
		integrationData.setIntegrationGroupName(groupName);
		info.setGroupName(groupName);
		LOGGER.debug("Setting Group Name: " + groupName);
		
		String folderPrefix = excelProjects.get(startProjectNumberForCurrentGroup - 1).getFolderName();
		String completeFolderName = getFolderName(folderPrefix, groupNo);

		int parentFolderId = getParentFolder(completeFolderName, url, username, password);
		integrationData.setFolderId(parentFolderId);
		integrationData.setFolderPath(completeFolderName);
		info.setParentFolderId(parentFolderId);
		info.setEp1PollingTime(getPollingTime());
		info.setEp2PollingTime(null);
		info.setChangeTargetProject(false);
		info.setProjectMapping(projectMappingContext);
		info.setBidirectionalIntegrations(getBidirectionalIntegrationInfo(groupNo, url, username, password,
				excelNameSourceFullNameMap.get(sourceProject),
				excelNameTargetFullNameMap.get(targetProject), sourceSystemId,
				targetSystemId,null));
		return info;
	}

	static String getIntegrationPostfixName(int groupNo) {
		return integrationDetails.getProperty(NAME_POSTFIX + groupNo);
	}

	static String getRequestBody(int groupNo, String url, String username, String password, int currentPod,
			IntegrationGroupInfo goupInfo) throws Exception {

		Map<String, Object> groupInfoMap = getMapFromObject(goupInfo);
		StringBuilder requestBodyStringBuilder = new StringBuilder("");
		requestBodyStringBuilder.append("{");
		requestBodyStringBuilder.append("\"query\"");
		requestBodyStringBuilder.append(":");
		requestBodyStringBuilder.append("\"");
		requestBodyStringBuilder.append("mutation");
		requestBodyStringBuilder.append("{");
		requestBodyStringBuilder.append("integrationGroupSchema");
		requestBodyStringBuilder.append("(");
		requestBodyStringBuilder.append("request:");
		requestBodyStringBuilder.append("{");
		requestBodyStringBuilder.append(getMutationArgQuery(groupInfoMap));
		requestBodyStringBuilder.append("}");
		requestBodyStringBuilder.append(")");
		requestBodyStringBuilder.append("{response{groupId}}");
		requestBodyStringBuilder.append("}");
		requestBodyStringBuilder.append("}");
		requestBodyStringBuilder.append("\"");
		requestBodyStringBuilder.append("}");
		return requestBodyStringBuilder.toString();
	}

	@SuppressWarnings("unchecked")
	private static Map<String, Object> getMapFromObject(final Object obj) {
		ObjectMapper mapper = new ObjectMapper();
		return mapper.convertValue(obj, Map.class);
	}

	static Integer getSourceSystemId(String url, String username, String password) throws Exception {
		String sourceSystemName = integrationDetails.getProperty(SOURCE_SYSTEM_NAME_KEY);
		LOGGER.debug("Source System Name: " + sourceSystemName);
		return Layer1.getSystemIdFromName(sourceSystemName, url, username, password);
	}

	static Integer getTargetSystemId(String url, String username, String password) throws Exception {
		String targetSystemName = integrationDetails.getProperty(TARGET_SYSTEM_NAME_KEY);
		LOGGER.debug("Target System Name: " + targetSystemName);
		return Layer1.getSystemIdFromName(targetSystemName, url, username, password);
	}

	static String[] getSourceProjects() {
		return integrationDetails.getProperty(SOURCE_PROJECT_KEY).split(",");
	}

	static String[] getTargetProjects() {
		return integrationDetails.getProperty(TARGET_PROJECT_KEY).split(",");
	}

	static String[] getMappingIds(int groupNo, String url, String username, String password) throws Exception {
		LOGGER.debug("Fetching mapping ids");
		String[] mappingNames = integrationDetails.getProperty(MAPPING_NAME + groupNo).split(",");
		String[] mappingIds = new String[mappingNames.length];
		for (int i = 0; i < mappingNames.length; ++i) {
			mappingIds[i] = String.valueOf(Layer1.getMappingIdFromName(mappingNames[i], url, username, password));
			LOGGER.debug("Mapping Name: " + mappingNames[i] + " Mapping id: " + mappingIds[i]);
		}
		return mappingIds;
	}

	static String[] getSourceIssueTypes(final int groupNo) {

		return integrationDetails.getProperty(SOURCE_ISSUE_TYPE_KEY + String.valueOf(groupNo)).split(",");
	}

	static String[] getTargetIssueTypes(final int groupNo) {
		return integrationDetails.getProperty(TARGET_ISSUE_TYPE_KEY + String.valueOf(groupNo)).split(",");
	}

	static String getPollingTime() {
		return integrationDetails.getProperty(POLLING_TIME);
	}

	static String[] getPollingTypes(final int groupNo) {
		return integrationDetails.getProperty(POLLING_TYPE + groupNo).split(",");
	}

	static int getStartCount(final int groupNo) {
		return Integer.parseInt(integrationDetails.getProperty(START_COUNT + groupNo));
	}

	static int getEndCount(final int groupNo) {
		return Integer.parseInt(integrationDetails.getProperty(END_COUNT + groupNo));
	}

	static Integer getScheduleId(final int groupNo, final int index) {
		String[] scheduleIds = integrationDetails.getProperty(SCHEDULE_ID_KEY + groupNo).split(",");
		return Integer.parseInt(scheduleIds[index]);
	}

	static Boolean getIsSearchInTarget(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty("searchInTarget" + groupNo));
	}

	static String getSearchQuery(int groupNo) {
		return integrationDetails.getProperty("searchQuery" + groupNo);
	}

	static String getIfMultipleFoundInTarget(int groupNo) {
		return integrationDetails.getProperty("ifMultipleInTarget" + groupNo);
	}

	static String getIsContinueSync(int groupNo) {
		return integrationDetails.getProperty("continueSync" + groupNo);
	}

	static String getIfNoEntityFound(int groupNo) {
		return integrationDetails.getProperty("ifNoEntityFound" + groupNo);
	}
	
	static Boolean getIsCriteriaEnabled(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty(ENABLE_CRITERIA + groupNo));
	}
	static String getAdditionalData(int groupNo) {
		return integrationDetails.getProperty(ADDITIONAL_DATA + groupNo);
	}
	static Boolean getIsCheckSourceEntityCountEnabled(int groupNo) {
		return Boolean.parseBoolean(integrationDetails.getProperty(CHECK_SOURCE_ENTITY_COUNT + groupNo));
	}
	static String getTargetRemoteLink(int groupNo) {
		return integrationDetails.getProperty(REMOTE_LINK + groupNo);
	}
	static String getTargetRemoteEntityId(int groupNo) {
		return integrationDetails.getProperty(REMOTE_ID + groupNo);
	}
	static String getCriteriaQuery(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_QUERY + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_QUERY + String.valueOf(groupNo)).trim():"";
	}
	static String getCriteriaStorage(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_STORAGE + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_STORAGE + String.valueOf(groupNo)).trim():"";
	}
	static String getCriteriaStorageFieldName(int groupNo) {
		return integrationDetails.containsKey(CRITERIA_STORAGE_FIELD + String.valueOf(groupNo))?integrationDetails.getProperty(CRITERIA_STORAGE_FIELD + String.valueOf(groupNo)).trim():"";
	}

	static List<BidirectionalIntegrationInfo> getBidirectionalIntegrationInfo(int groupNo, String url, String username,
			String password, String sourceProjectInternalId, String targetProjectInternalId, Integer sourceSystemId,
			Integer targetSystemId, String excelCriteria) throws Exception {
		List<BidirectionalIntegrationInfo> bidirectionIntegrationInfo = new ArrayList<>();
		String[] sourceIssueTypes = getSourceIssueTypes(groupNo);
		String[] targetIssueTypes = getTargetIssueTypes(groupNo);
		String[] sourceIssueTypeIds = Layer1.getIssueTypeInternalNameFromDisplayName(url, sourceProjectInternalId,
				username, password, sourceIssueTypes, sourceSystemId);
		String[] targetIssueTypeIds = Layer1.getIssueTypeInternalNameFromDisplayName(url, targetProjectInternalId,
				username, password, targetIssueTypes, targetSystemId);
		String[] mappingIds = getMappingIds(groupNo, url, username, password);
		String[] pollingTypes = getPollingTypes(groupNo);
		if (sourceIssueTypeIds.length == targetIssueTypeIds.length && sourceIssueTypeIds.length == mappingIds.length
				&& sourceIssueTypeIds.length == pollingTypes.length) {
			for (int i = 0; i < sourceIssueTypes.length; ++i) {
				BidirectionalIntegrationInfo bidirectionInfo = new BidirectionalIntegrationInfo();
				bidirectionInfo.setIntegrationId(-1);
				bidirectionInfo.setDirection(ConfigDirection.FORWARD);
				UnidirectionalIntegrationData forwardSetting = new UnidirectionalIntegrationData();
				forwardSetting.setUnidirectionalId(-1);
				forwardSetting.setPollingType(Integer.parseInt(pollingTypes[i]));
				if (getIsSearchInTarget(groupNo)) {
					// TODO if any field is null, throw exception
					LOGGER.debug("Target search look up is enabled.");
					TargetLookup targetLookup = new TargetLookup();
					targetLookup.setIsTargetLookup("1");
					targetLookup.setTargetLookUpQuery(getSearchQuery(groupNo));
					targetLookup.setResolutionOption(getIfMultipleFoundInTarget(groupNo));
					targetLookup.setIsContinueUpdate(getIsContinueSync(groupNo));
					targetLookup.setIsCreateOnNotFound(getIfNoEntityFound(groupNo));
					forwardSetting.setTargetLookUpContext(targetLookup);
				}
				if (getIsCriteriaEnabled(groupNo)) {
					// TODO if any field is null, throw exception
					LOGGER.debug("Criteria is enabled.");
					CriteriaContext context = new CriteriaContext();
					// 1 - Yes
					// 0 - No
					context.setConfigureCriteria("1");
					String criteriaQuery = getCriteriaQuery(groupNo);
					if(criteriaQuery.isEmpty()) {
						LOGGER.error("Criteria is enabled and Criteria Query Found Empty");
						throw new Exception("Criteria is enabled and Criteria Query Found Empty");
					}else {
						context.setQuery(criteriaQuery);
					}
					
					// 1 - For Database
					// 2 - For EndSystems
					String criteriaStorageType = getCriteriaStorage(groupNo);
					if(criteriaStorageType.isEmpty()) {
						LOGGER.error("Criteria is enabled and Criteria Strorage Type Found Empty");
						throw new Exception("Criteria is enabled and Criteria Strorage Type Found Empty");
					}else {
						context.setCriteriaStorageType(criteriaStorageType);
					}
					
					
					if(getCriteriaStorage(groupNo).equals("2")) {
						LOGGER.debug("End System Storage type is select as Criteria Storage type");
						context.setFieldForCriteriaInfoStorage(getCriteriaStorageFieldName(groupNo));
					}
					forwardSetting.setCriteria(context);
				}
				RemoteLinkage remoteLinkContext = new RemoteLinkage();
				String remoteLink = getTargetRemoteLink(groupNo);
				String remoteId = getTargetRemoteEntityId(groupNo);
				if (remoteLink!=null && !remoteLink.isEmpty()) {
					LOGGER.debug("Setting Remote Link:-"+remoteLink);
					remoteLinkContext.setTargetLinkField(remoteLink);
				}
				if (remoteId!=null && !remoteId.isEmpty()) {
					LOGGER.debug("Setting Remote Entity Id:-"+remoteId);
					remoteLinkContext.setTargetEntityIdField(remoteId);
				}
				forwardSetting.setRemoteLinkContext(remoteLinkContext);
				if(excelCriteria!=null && !excelCriteria.isEmpty()) {
					LOGGER.debug("Criteria from the excel found. Setting Criteria:"+ excelCriteria +" with Storage optio:  'In Database'");
					CriteriaContext context = new CriteriaContext();
					// 1 - Yes
					// 0 - No
					context.setConfigureCriteria("1");
					context.setQuery(excelCriteria);
					context.setCriteriaStorageType("1");
					forwardSetting.setCriteria(context);
				}
				SourceContext sourceContext = new SourceContext();
				// all are in current state
				sourceContext.setCurrentStateSyncFlag(CURRENT_STATE_FLAG);
				String pollerPageSize = integrationDetails.getProperty("pollerPageSize");
				if (pollerPageSize != null && !pollerPageSize.isEmpty()) {
					LOGGER.debug("Setting pollerPageSize:" + pollerPageSize);
					sourceContext.setPollerPageSize(pollerPageSize);
				}
				String additionalData = getAdditionalData(groupNo);
				if (additionalData!=null && !additionalData.isEmpty()) {
					ObjectMapper obj = new ObjectMapper();
					sourceContext.setAdditionalData(obj.readValue(additionalData,new TypeReference<List<ContextData>>(){}));
				}
				sourceContext.setIssueType(sourceIssueTypeIds[i]);
				forwardSetting.setSourceContext(sourceContext);
				TargetContext targetContext = new TargetContext();
				targetContext.setIssueType(targetIssueTypeIds[i]);

				forwardSetting.setTargetContext(targetContext);
				forwardSetting.setScheduleId(getScheduleId(groupNo, i));
				forwardSetting.setEvents(getEvents(groupNo, mappingIds[i], i));
				forwardSetting.setIntegrationContext(getIntegrationContext());
				bidirectionInfo.setForwardSettings(forwardSetting);

				bidirectionIntegrationInfo.add(bidirectionInfo);
			}
		} else {
			LOGGER.error("Source Issue Type length is not the same as target issue type length for group:" + groupNo
					+ " Source Issue Type:" + sourceIssueTypes.length + " Target Issue Type" + targetIssueTypes.length);
			throw new Exception("Source Issue Type and Target Issue Type length are not same for group:" + groupNo);
		}
		return bidirectionIntegrationInfo;
	}

	public static void createReconciliation(String url, String username, String password) throws Exception {
		loadReconcileProperties();
		String folderName = getReconcileFolderName();
		String sourceIssueType = getReconcileSourceIssueType();
		String targetIssueType = getReconcileTargetIssueType();
		LOGGER.debug("Folder Name:" + folderName);
		LOGGER.debug("Source Issue Type:" + sourceIssueType);
		LOGGER.debug("Target Issue Type:" + targetIssueType);
		String[] separateFolders = folderName.split("/");
		if (separateFolders.length == 0 || !separateFolders[0].equalsIgnoreCase("default")) {
			throw new Exception("Folder does not exist: " + folderName + " Folder name should start with default");
		}
		int parentId = 0;
		for (int i = 1; i < separateFolders.length; ++i) {
			parentId = Layer1.getFolderIdByName(url, separateFolders[i], parentId, username, password);
		}
		LOGGER.debug("Found folder id:" + parentId + " Folder Name:" + folderName);
		if (parentId == -1) {
			LOGGER.error("Could not find folder id for folder:" + folderName
					+ " Please verify whether the folder exists or not.");
			throw new Exception("Folder does not exist: " + folderName);
		} else {
			int[] groupIds = getIntegrationGroupIdsByFolder(url, username, password, parentId);
			LOGGER.debug("Folder Name:" + folderName + " No of integration groups:" + groupIds.length);
			List<Integer> reconcileIds = new ArrayList<>();
			if (groupIds != null) {
				for (int i = 0; i < groupIds.length; ++i) {
					JSONObject integrationDetails = getIntegrationDetailsFromGroupId(url, username, password, parentId,
							groupIds[i]);
					if (integrationDetails != null) {
						List<Integer> mappingIds = new ArrayList<>();
						List<Integer> integrationIds = getIntegrationIdsForReconcile(integrationDetails,
								sourceIssueType, targetIssueType, mappingIds);

						for (int cur = 0; cur < integrationIds.size(); ++cur) {
							int reconcileId = reconcileIntegration(integrationIds.get(cur), url, username, password,
									mappingIds.get(0));
							reconcileIds.add(reconcileId);
						}
					} else {
						LOGGER.error("Could not get integration details from group id:" + groupIds[i]);
						throw new Exception("Could not get integration details from a folder.");
					}
				}
			}
			activateReconcileIds(reconcileIds, url, username, password);

		}
	}

	static int reconcileIntegration(int integrationId, String url, String username, String password, int mappingId)
			throws Exception {
		reconcileDetails.getProperty("reconcileWorkflowId");
		LOGGER.debug("Reconciling integration with id:" + integrationId);
		String params = getRequestBodyForReconcilation(integrationId);
		getAndSaveMappingDetails(url, username, password, mappingId);
		int reconcileId = Layer1.reconcileIntegration(url, username, password, params);
		return reconcileId;
		// if (reconcileId > 0) {
		// if (getActiveAfterCreation()) {
		// LOGGER.debug("activeAfterCreate is enabled. Activating
		// reconciliation: " + reconcileId);
		// String requestBody = "{\"query\":
		// \"mutation{actionHandler(action:\\\"status\\\",entity:\\\"reconcile\\\",ids:["
		// + reconcileId + "],value:\\\"Run\\\"){result}}\"}";
		// Layer1.activateReconciliation(url, username, password, requestBody);
		// } else {
		// LOGGER.debug("activeAfterCreate is false, hence not activating
		// reconciliation with id:" + reconcileId);
		// }
		// } else {
		// LOGGER.error("Could not fetch reconciliation id");
		// }
	}

	static void activateReconcileIds(List<Integer> reconcileIds, String url, String username, String password)
			throws Exception {
		LOGGER.debug("Activating reconcile ids: " + reconcileIds.toString());
		if (getActiveAfterCreation()) {
			StringBuilder sb = new StringBuilder("");
			for (int i = 0; i < reconcileIds.size(); ++i) {
				sb.append(String.valueOf(reconcileIds.get(i)));
				if (i != reconcileIds.size() - 1) {
					sb.append(",");
				}
			}

			LOGGER.debug("activeAfterCreate is enabled. Activating reconciliation: " + sb.toString());
			String requestBody = "{\"query\": \"mutation{actionHandler(action:\\\"status\\\",entity:\\\"reconcile\\\",ids:["
					+ sb.toString() + "],value:\\\"Run\\\"){result}}\"}";
			System.out.println(requestBody);
			Layer1.activateReconciliation(url, username, password, requestBody);
		} else {
			LOGGER.debug("activeAfterCreate is false, hence not activating reconciliation");
		}
	}

	public static void getAndSaveMappingDetails(String url, String username, String password, int mappingId)
			throws Exception {
		Mapper mapper = Layer1.getMappingDetailsForReconcile(url, username, password, mappingId);
		mapper.setTransitionConfig(new MapperTransitionConfig());
		List<MapperFieldConfig> fields = mapper.getFields();
		for (MapperFieldConfig field : fields) {
			MapperFieldSettings forwardSetting = field.getForwardSettings();
			RuleItem reconcileRule = new RuleItem();
			reconcileRule.setForCreate(true);
			reconcileRule.setForUpdate(true);
			reconcileRule.setMismatchStrategy("Source");
			forwardSetting.setReconcileRule(reconcileRule);
		}
		Map<String, Object> requestMap = getMapFromObject(mapper);
		String body = getMutationArgQuery(requestMap);
		StringBuilder requestBody = new StringBuilder("");
		requestBody.append("{\"query\": \"mutation{mapper(request : {");
		requestBody.append(body);
		requestBody.append(
				"}){response{mappingId,validationResult{endPoint1Name,endPoint2Name ,invalidFieldsData{key,invalidFields},invalidEnumsData{endPoint1FieldDisplayName,endPoint2FieldDisplayName,missingEndPoint1Enum,invalidEnums},confirmRuleDelete}}}}\"}");
		Layer1.saveReconcileRules(url, username, password, requestBody.toString());
	}

	static String getRequestBodyForReconcilation(int integrationId) {
		String recoWorkflowId = getReconcileWorkflowId();
		StringBuilder body = new StringBuilder("");
		body.append("{");
		body.append("\"query\"");
		body.append(":");
		body.append("\"mutation{reconciliationSchema(request : [{integrationId : " + integrationId
				+ ",status : 2,workflowDefination : { processDefnId : " + recoWorkflowId
				+ " }}]){response{reconcileResponse{integrationId,reconciliationId,status,reconciliationName, targetSearchQuery,targetQueryCriteria},validationResponse{forKey,forObjectType,messages}}}}\"");
		body.append("}");
		return body.toString();
	}

	static List<Integer> getIntegrationIdsForReconcile(JSONObject integrationDetails, String sourceIssueType,
			String targetIssueType, List<Integer> mappingIds) {
		// TODO: Restructure
		List<Integer> ids = new ArrayList<>();
		try {
			JSONObject integrationList = integrationDetails.getJSONObject("integrationList");
			JSONArray list = integrationList.getJSONArray("list");
			for (int i = 0; i < list.length(); ++i) {
				JSONObject forwardSettings = list.getJSONObject(i).getJSONObject("forwardSettings");
				String sourceContext = forwardSettings.getJSONObject("sourceContext").getString("issueType");
				String targetContext = forwardSettings.getJSONObject("targetContext").getString("issueType");
				String mode = forwardSettings.getJSONObject("currentMode").getString("mode");
				if (sourceContext.equalsIgnoreCase(sourceIssueType) && targetContext.equalsIgnoreCase(targetIssueType)
						&& mode.equalsIgnoreCase("Integration")) {
					ids.add(forwardSettings.getInt("unidirectionalId"));
					int mappingId = forwardSettings.getJSONArray("events").getJSONObject(0).getJSONArray("processDefs")
							.getJSONObject(0).getInt("transformations");
					mappingIds.add(mappingId);
				}
			}
		} catch (JSONException e) {

		}

		return ids;
	}

	static JSONObject getIntegrationDetailsFromGroupId(String url, String username, String password, int folderId,
			int groupId) throws Exception {
		// TODO: Pagination handling

		IntegrationList integrationList = new IntegrationList();
		integrationList.setFetchAllAccessibleIntegrationItems(false);
		integrationList.setFolderId(folderId);
		Filter filter = new Filter("integrationGroup.groupId", "EQUAL", String.valueOf(groupId));
		List<Filter> filterList = new ArrayList<>();
		filterList.add(filter);
		integrationList.setFilterList(filterList);
		Pager pager = new Pager();
		pager.setNumberOfRecords(5000);
		pager.setRecordNumber(0);
		pager.setPageSize(5000);
		integrationList.setPager(pager);
		Map<String, Object> requestMap = getMapFromObject(integrationList);
		String paramString = getIntegrationDetailRequestBody(requestMap);
		paramString = paramString.replaceAll("\\\\", "");
		return Layer1.getIntegrationDetailsByGroupId(url, username, password, paramString);
	}

	static String getIntegrationDetailRequestBody(Map<String, Object> requestMap) {
		StringBuilder body = new StringBuilder("");
		body.append("{integrationList(");
		body.append(getMutationArgQuery(requestMap));
		body.append(
				"){list{integrationId,forwardSettings{unidirectionalId,sourceContext{issueType},targetContext{issueType},events{processDefs{transformations}},currentMode{mode}}}}}");
		return body.toString();
	}

	static int[] getIntegrationGroupIdsByFolder(String url, String username, String password, int folderId)
			throws Exception {
		// TODO: Pagination handling

		IntegrationGroupList integrationGroupList = new IntegrationGroupList();
		integrationGroupList.setFetchAllAccessibleIntegrationItems(false);
		integrationGroupList.setSearchText(null);
		integrationGroupList.setFolderId(folderId);
		Pager pager = new Pager();
		pager.setNumberOfRecords(5000);
		pager.setPageSize(5000);
		pager.setRecordNumber(0);
		integrationGroupList.setPager(pager);
		Map<String, Object> requestMap = getMapFromObject(integrationGroupList);
		String requestBody = getRequestBodyForIntegrationGroupList(requestMap);
		return Layer1.getAllIntegrationGroupIds(url, username, password, requestBody);
	}

	static String getRequestBodyForIntegrationGroupList(Map<String, Object> requestMap) {
		StringBuilder requestBody = new StringBuilder("");
		requestBody.append("{");
		requestBody.append("integrationGroupList");
		requestBody.append("(");
		requestBody.append(getMutationArgQuery(requestMap));
		requestBody.append(")");
		requestBody.append("{list{groupId}}");
		requestBody.append("}");
		return requestBody.toString();
	}

	static String getReconcileFolderName() {
		return reconcileDetails.getProperty("folderName");
	}

	static String getReconcileSourceIssueType() {
		return reconcileDetails.getProperty("sourceIssueType");
	}

	static String getReconcileTargetIssueType() {
		return reconcileDetails.getProperty("targetIssueType");
	}
	static String getReconcileWorkflowId() {
		return (reconcileDetails.getProperty("reconcileWorkflowId")==null || reconcileDetails.getProperty("reconcileWorkflowId").isEmpty())?String.valueOf(DEFAULT_RECONCILE_WORKFLOW_ID):reconcileDetails.getProperty("reconcileWorkflowId");
	}

	static boolean getActiveAfterCreation() {
		return Boolean.parseBoolean(reconcileDetails.getProperty("activeAfterCreate"));
	}

	static String getFolderName(String folderPrefix, int groupNo) {
		String postFix = integrationDetails.getProperty(PARENT_FOLDER_PATH_KEY + groupNo);
		boolean doOverwrite = Boolean.parseBoolean(integrationDetails.getProperty("overwriteFolder" + groupNo));
		if (doOverwrite && postFix != null && !postFix.isEmpty()) {
			LOGGER.debug("Overwrite is true for group no:" + groupNo + " for folder name. Hence returning:Default/"
					+ postFix);
			return "Default/" + postFix;
		}
		String folderName = folderPrefix + "/" + postFix;
		LOGGER.debug("Generated folder name:" + folderName);
		return folderName;
	}

	public static void loadReconcileProperties() throws Exception {
		LOGGER.debug("Loading properties for reconciliation from: " + RECONCILE_DETAILS_FILE);
		InputStream inputStream = null;
		try {
			reconcileDetails = new Properties();
			inputStream = Layer2.class.getClassLoader().getResourceAsStream(RECONCILE_DETAILS_FILE);
			reconcileDetails.load(inputStream);
		} catch (Exception e) {
			LOGGER.error(
					"Failed to load properties from " + RECONCILE_DETAILS_FILE + " file. Caused by: " + e.getMessage());
			throw new Exception(
					"Failed to load properties from " + RECONCILE_DETAILS_FILE + " file. Caused by: " + e.getMessage());
		}
	}

	static int getParentFolder(final String folderName, String url, String username, String password) throws Exception {
		int prevId = 0;
		try {
			String[] folders = folderName.split("/");
			for (int i = 1; i < folders.length; ++i) {
				int currentFolderId = Layer1.getFolderIdByName(url, folders[i], prevId, username, password);
				if (currentFolderId == -1) {
					LOGGER.debug("Folder does not exist: " + folders[i] + ". Hence creating..");
					int createdFolderId = Layer1.createFolder(url, folders[i], prevId, username, password);
					LOGGER.debug("Created folder with id: " + createdFolderId);
					prevId = createdFolderId;
				} else {
					prevId = currentFolderId;
				}
			}

		} catch (Exception e) {
			LOGGER.error("Error occurred while creating folder:" + folderName + " . Caused by: " + e.getMessage());
			throw new Exception("Error occurred getting/creating folder: " + folderName);
		}

		return prevId;
	}

	static String getMutationArgQuery(final Map<String, Object> map) {
		List<String> keyValuePair = new ArrayList<>();
		for (Map.Entry<String, Object> obj : map.entrySet()) {
			if (obj.getValue() == null) {
				// Skip fields which having value null on mutation query
				continue;
			}
			StringBuilder strKeyValue = new StringBuilder();
			strKeyValue.append(obj.getKey());
			strKeyValue.append(":");
			if (obj.getValue() instanceof Integer || obj.getValue() instanceof Long) {
				strKeyValue.append(obj.getValue());
			} else if (obj.getValue() instanceof Boolean) {
				strKeyValue.append(String.valueOf(obj.getValue()));
			} else if (obj.getValue() instanceof String) {
				strKeyValue.append("\\\"");
				String valueAsStr = escapeString(String.valueOf(obj.getValue()));
				strKeyValue.append(valueAsStr.replace("\"", "\\\""));
				strKeyValue.append("\\\"");
			} else if (obj.getValue() instanceof List) {
				List<Map<String, Object>> map1 = (List<Map<String, Object>>) obj.getValue();
				List<String> listStrings = new ArrayList<>();
				for (Object listObj : map1) {
					if (listObj instanceof Map) {
						listStrings.add("{" + getMutationArgQuery((Map<String, Object>) listObj) + "}");
					} else if (listObj instanceof Integer) {
						listStrings.add(escapeString(String.valueOf(listObj)));
					} else if (listObj instanceof String) {
						listStrings.add("\\\"" + escapeString(String.valueOf(listObj)) + "\\\"");
					} else {
						throw new RuntimeException(
								"This datatype is not yet supported in Automation Mutation Query Builder.");
					}
				}
				strKeyValue.append("[");
				if (listStrings.size() > 0) {
					strKeyValue.append(String.join(",", listStrings));
				}
				strKeyValue.append("]");

			} else if (obj.getValue() instanceof Map) {
				strKeyValue.append("{");
				strKeyValue.append(getMutationArgQuery((Map<String, Object>) obj.getValue()));
				strKeyValue.append("}");
			}
			keyValuePair.add(strKeyValue.toString());
		}
		return String.join(",", keyValuePair);
	}

	static String escapeString(final String string) {
		return string.replace("\n", "\\\\n").replace("\r", "\\\\r").replace("\"", "\\\\\"");
	}

}
